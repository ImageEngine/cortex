<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Cortex: IECoreGL::Shader Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.6.1 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<script type="text/javascript">
<!--
function changeDisplayState (e){
  var num=this.id.replace(/[^[0-9]/g,'');
  var button=this.firstChild;
  var sectionDiv=document.getElementById('dynsection'+num);
  if (sectionDiv.style.display=='none'||sectionDiv.style.display==''){
    sectionDiv.style.display='block';
    button.src='open.gif';
  }else{
    sectionDiv.style.display='none';
    button.src='closed.gif';
  }
}
function initDynSections(){
  var divs=document.getElementsByTagName('div');
  var sectionCounter=1;
  for(var i=0;i<divs.length-1;i++){
    if(divs[i].className=='dynheader'&&divs[i+1].className=='dynsection'){
      var header=divs[i];
      var section=divs[i+1];
      var button=header.firstChild;
      if (button!='IMG'){
        divs[i].insertBefore(document.createTextNode(' '),divs[i].firstChild);
        button=document.createElement('img');
        divs[i].insertBefore(button,divs[i].firstChild);
      }
      header.style.cursor='pointer';
      header.onclick=changeDisplayState;
      header.id='dynheader'+sectionCounter;
      button.src='closed.gif';
      section.id='dynsection'+sectionCounter;
      section.style.display='none';
      section.style.marginLeft='14px';
      sectionCounter++;
    }
  }
}
window.onload = initDynSections;
-->
</script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <img id="MSearchSelect" src="search/search.png"
             onmouseover="return searchBox.OnSearchSelectShow()"
             onmouseout="return searchBox.OnSearchSelectHide()"
             alt=""/>
        <input type="text" id="MSearchField" value="Search" accesskey="S"
             onfocus="searchBox.OnSearchFieldFocus(true)" 
             onblur="searchBox.OnSearchFieldFocus(false)" 
             onkeyup="searchBox.OnSearchFieldChange(event)"/>
        <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
        </div>
      </li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="namespaceIECoreGL.html">IECoreGL</a>::<a class="el" href="classIECoreGL_1_1Shader.html">Shader</a>
  </div>
</div>
<div class="contents">
<h1>IECoreGL::Shader Class Reference</h1><!-- doxytag: class="IECoreGL::Shader" --><!-- doxytag: inherits="IECoreGL::Bindable" -->
<p>A class to represent GLSL shaders.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="L_2Shader_8h_source.html">Shader.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for IECoreGL::Shader:</div>
<div class="dynsection">
 <div class="center">
  <img src="classIECoreGL_1_1Shader.gif" usemap="#IECoreGL::Shader_map" alt=""/>
  <map id="IECoreGL::Shader_map" name="IECoreGL::Shader_map">
<area href="classIECoreGL_1_1Bindable.html" alt="IECoreGL::Bindable" shape="rect" coords="0,112,140,136"/>
<area href="classIECore_1_1RunTimeTyped.html" alt="IECore::RunTimeTyped" shape="rect" coords="0,56,140,80"/>
<area href="classIECore_1_1RefCounted.html" alt="IECore::RefCounted" shape="rect" coords="0,0,140,24"/>
</map>
 </div>
</div>

<p><a href="classIECoreGL_1_1Shader-members.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4e7a8a71d6633927175b9d56f2d84d4a"></a><!-- doxytag: member="IECoreGL::Shader::IE_CORE_DECLARERUNTIMETYPEDEXTENSION" ref="a4e7a8a71d6633927175b9d56f2d84d4a" args="(IECoreGL::Shader, ShaderTypeId, Bindable)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><b>IE_CORE_DECLARERUNTIMETYPEDEXTENSION</b> (<a class="el" href="classIECoreGL_1_1Shader.html">IECoreGL::Shader</a>, ShaderTypeId, <a class="el" href="classIECoreGL_1_1Bindable.html">Bindable</a>)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIECoreGL_1_1Shader.html#a419abf697453a4abda11fb887de28aa9">Shader</a> (const std::string &amp;vertexSource, const std::string &amp;fragmentSource)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1ead69dead641b13431288fc8e797abf"></a><!-- doxytag: member="IECoreGL::Shader::operator==" ref="a1ead69dead641b13431288fc8e797abf" args="(const Shader &amp;other) const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="classIECoreGL_1_1Shader.html">Shader</a> &amp;other) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIECoreGL_1_1Shader.html#aef1ad01d07573c56d6135be18027e608">bind</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIECoreGL_1_1Shader.html#a045d1d76de0fff1b9004c8b2b466a8ce">uniformParameterNames</a> (std::vector&lt; std::string &gt; &amp;names) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">GLint&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIECoreGL_1_1Shader.html#a57f96adc255f9308f708212b4acedce8">uniformParameterIndex</a> (const std::string &amp;parameterName) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8bb6e046c0c84d3664e3b4dd5a7b8877"></a><!-- doxytag: member="IECoreGL::Shader::hasUniformParameter" ref="a8bb6e046c0c84d3664e3b4dd5a7b8877" args="(const std::string &amp;parameterName) const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIECoreGL_1_1Shader.html#a8bb6e046c0c84d3664e3b4dd5a7b8877">hasUniformParameter</a> (const std::string &amp;parameterName) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns true if the <a class="el" href="classIECoreGL_1_1Shader.html" title="A class to represent GLSL shaders.">Shader</a> has a uniform parameter of the given name. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceIECore.html#af294ec67f3b39230d75efef3844cf448">IECore::TypeId</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIECoreGL_1_1Shader.html#af1294cfcf9fa9c128413be0a3e66bf2f">uniformParameterType</a> (GLint parameterIndex) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3c60e97d0d971f0df53fbc6652712d31"></a><!-- doxytag: member="IECoreGL::Shader::uniformParameterType" ref="a3c60e97d0d971f0df53fbc6652712d31" args="(const std::string &amp;parameterName) const " -->
<a class="el" href="namespaceIECore.html#af294ec67f3b39230d75efef3844cf448">IECore::TypeId</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIECoreGL_1_1Shader.html#a3c60e97d0d971f0df53fbc6652712d31">uniformParameterType</a> (const std::string &amp;parameterName) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">As above but by specifying the parameter by name. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIECoreGL_1_1Shader.html#ac5ccdf1fabbeb45de97bcb9684570b36">vertexParameterNames</a> (std::vector&lt; std::string &gt; &amp;names) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fills the passed vector with the names of all vertex shader parameters.  <a href="#ac5ccdf1fabbeb45de97bcb9684570b36"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">GLint&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIECoreGL_1_1Shader.html#ac6f0cb63d750bda1eff8e76b820b800e">vertexParameterIndex</a> (const std::string &amp;parameterName) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9c946684cd5a1ee1752bbf5219e03ace"></a><!-- doxytag: member="IECoreGL::Shader::hasVertexParameter" ref="a9c946684cd5a1ee1752bbf5219e03ace" args="(const std::string &amp;parameterName) const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIECoreGL_1_1Shader.html#a9c946684cd5a1ee1752bbf5219e03ace">hasVertexParameter</a> (const std::string &amp;parameterName) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns true if the <a class="el" href="classIECoreGL_1_1Shader.html" title="A class to represent GLSL shaders.">Shader</a> has a vertex parameter of the given name. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIECoreGL_1_1Shader.html#aeff90c5c585545a615909b2fa357ac3e">vertexValueValid</a> (GLint parameterIndex, const <a class="el" href="classIECore_1_1Data.html">IECore::Data</a> *value) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af5be188ccf642efb3adb89dad4c5f22b"></a><!-- doxytag: member="IECoreGL::Shader::vertexValueValid" ref="af5be188ccf642efb3adb89dad4c5f22b" args="(const std::string &amp;parameterName, const IECore::Data *value) const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIECoreGL_1_1Shader.html#af5be188ccf642efb3adb89dad4c5f22b">vertexValueValid</a> (const std::string &amp;parameterName, const <a class="el" href="classIECore_1_1Data.html">IECore::Data</a> *value) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">As above, but specifying the vertex parameter by name. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIECoreGL_1_1Shader.html#a446ea1095492b6191e353df01d3f5157">setVertexParameter</a> (GLint parameterIndex, const <a class="el" href="classIECore_1_1Data.html">IECore::Data</a> *value, bool normalize=false)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae73b23d1535c5a283dcf365ae2295a38"></a><!-- doxytag: member="IECoreGL::Shader::setVertexParameter" ref="ae73b23d1535c5a283dcf365ae2295a38" args="(const std::string &amp;parameterName, const IECore::Data *value, bool normalize=false)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIECoreGL_1_1Shader.html#ae73b23d1535c5a283dcf365ae2295a38">setVertexParameter</a> (const std::string &amp;parameterName, const <a class="el" href="classIECore_1_1Data.html">IECore::Data</a> *value, bool normalize=false)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">As above, but specifying the vertex parameter by name. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af73d0fdc740a044077a6daa7d2bd7ddf"></a><!-- doxytag: member="IECoreGL::Shader::unsetVertexParameters" ref="af73d0fdc740a044077a6daa7d2bd7ddf" args="()" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIECoreGL_1_1Shader.html#af73d0fdc740a044077a6daa7d2bd7ddf">unsetVertexParameters</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unsets all vertex parameters from the shader. <br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">getUniformParameterDefault</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp48633f7292f8f5dd778795ce36eaeddf"></a> Returns a new data object containing the suggested default value (zero) to be set on the given parameter. The default values are not supported by OpenGL. So the shader does not have to be bound at the time of calling. </p>
<br/><br/></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af8546108a19a57fb0760c385d740ec20"></a><!-- doxytag: member="IECoreGL::Shader::getUniformParameterDefault" ref="af8546108a19a57fb0760c385d740ec20" args="(GLint parameterIndex) const " -->
IECore::DataPtr&nbsp;</td><td class="memItemRight" valign="bottom"><b>getUniformParameterDefault</b> (GLint parameterIndex) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8fd053c5aa683615c8413d1527f10587"></a><!-- doxytag: member="IECoreGL::Shader::getUniformParameterDefault" ref="a8fd053c5aa683615c8413d1527f10587" args="(const std::string &amp;parameterName) const " -->
IECore::DataPtr&nbsp;</td><td class="memItemRight" valign="bottom"><b>getUniformParameterDefault</b> (const std::string &amp;parameterName) const </td></tr>
<tr><td colspan="2"><div class="groupHeader">Uniform Parameter getting</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp37aa22f710222ae540a889733a5bf2a8"></a> These calls return the current values of shader uniform parameters. Unlike the calls to set values (see below) the shader does not have to be bound at the time of calling. </p>
<br/><br/></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8296d9c9ade06edb9565812dfffad012"></a><!-- doxytag: member="IECoreGL::Shader::getUniformParameter" ref="a8296d9c9ade06edb9565812dfffad012" args="(GLint parameterIndex) const " -->
IECore::DataPtr&nbsp;</td><td class="memItemRight" valign="bottom"><b>getUniformParameter</b> (GLint parameterIndex) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aefe7755224a448e00d3a7745da45ba61"></a><!-- doxytag: member="IECoreGL::Shader::getUniformParameter" ref="aefe7755224a448e00d3a7745da45ba61" args="(const std::string &amp;parameterName) const " -->
IECore::DataPtr&nbsp;</td><td class="memItemRight" valign="bottom"><b>getUniformParameter</b> (const std::string &amp;parameterName) const </td></tr>
<tr><td colspan="2"><div class="groupHeader">Uniform Parameter setting</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp34747e7443703780cfef80cfcdc6b1f5"></a> These calls set shader parameters. They can only be called while the <a class="el" href="classIECoreGL_1_1Shader.html" title="A class to represent GLSL shaders.">Shader</a> is bound (using <a class="el" href="classIECoreGL_1_1Shader.html#aef1ad01d07573c56d6135be18027e608">bind()</a>) as the current shader - Exceptions will result if this is not the case. </p>
<br/><br/></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIECoreGL_1_1Shader.html#a21bd15bca3c4f36c7d5a87f35df90fd0">uniformValueValid</a> (GLint parameterIndex, <a class="el" href="namespaceIECore.html#af294ec67f3b39230d75efef3844cf448">IECore::TypeId</a> type) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIECoreGL_1_1Shader.html#ad29a9044aa9fa20fbcc4906242579a8d">uniformValueValid</a> (GLint parameterIndex, const <a class="el" href="classIECore_1_1Data.html">IECore::Data</a> *value) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac921c3e5933473ccfff1379ceb16a83a"></a><!-- doxytag: member="IECoreGL::Shader::uniformValueValid" ref="ac921c3e5933473ccfff1379ceb16a83a" args="(const std::string &amp;parameterName, const IECore::Data *value) const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIECoreGL_1_1Shader.html#ac921c3e5933473ccfff1379ceb16a83a">uniformValueValid</a> (const std::string &amp;parameterName, const <a class="el" href="classIECore_1_1Data.html">IECore::Data</a> *value) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">As above, but specifying the uniform parameter by name. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIECoreGL_1_1Shader.html#a7ea49a456eec79af25ec464b8af33e90">setUniformParameter</a> (GLint parameterIndex, const <a class="el" href="classIECore_1_1Data.html">IECore::Data</a> *value)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">boost::disable_if_c<br class="typebreak"/>
&lt; boost::is_convertible&lt; T, <br class="typebreak"/>
<a class="el" href="classIECore_1_1Data.html">IECore::Data</a> * &gt;::value &gt;<br class="typebreak"/>
::type&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classIECoreGL_1_1Shader.html#a7cc614ecd21427002d69d61eeea0622d">setUniformParameter</a> (GLint parameterIndex, const T &amp;value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIECoreGL_1_1Shader.html#a9c3d244de16b34e65b5bb89b9091681d">setUniformParameter</a> (const std::string &amp;parameterName, const <a class="el" href="classIECore_1_1Data.html">IECore::Data</a> *value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a208add79b7e19021c19d5deba802b7b7"></a><!-- doxytag: member="IECoreGL::Shader::setUniformParameter" ref="a208add79b7e19021c19d5deba802b7b7" args="(GLint parameterIndex, unsigned int textureUnit)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIECoreGL_1_1Shader.html#a208add79b7e19021c19d5deba802b7b7">setUniformParameter</a> (GLint parameterIndex, unsigned int textureUnit)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the specified sampler parameter to use the texture unit indicated. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIECoreGL_1_1Shader.html#a74bfaec9ee0b7c942e062da960be50c9">setUniformParameter</a> (const std::string &amp;parameterName, unsigned int textureUnit)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4f3e729c348d662784772dca9ce8e914"></a><!-- doxytag: member="IECoreGL::Shader::setUniformParameter" ref="a4f3e729c348d662784772dca9ce8e914" args="(GLint parameterIndex, int value)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>setUniformParameter</b> (GLint parameterIndex, int value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa0daf1250d34c00d7b5a350de8241eea"></a><!-- doxytag: member="IECoreGL::Shader::setUniformParameter" ref="aa0daf1250d34c00d7b5a350de8241eea" args="(const std::string &amp;parameterName, int value)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>setUniformParameter</b> (const std::string &amp;parameterName, int value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIECoreGL_1_1Shader.html#a1b669db0b38ac64613a18e44e7e3e508">uniformVectorValueValid</a> (GLint parameterIndex, const <a class="el" href="classIECore_1_1Data.html">IECore::Data</a> *value) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a17a3497a3b66f9a90ca02d86e677f903"></a><!-- doxytag: member="IECoreGL::Shader::uniformVectorValueValid" ref="a17a3497a3b66f9a90ca02d86e677f903" args="(const std::string &amp;parameterName, const IECore::Data *value) const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIECoreGL_1_1Shader.html#a17a3497a3b66f9a90ca02d86e677f903">uniformVectorValueValid</a> (const std::string &amp;parameterName, const <a class="el" href="classIECore_1_1Data.html">IECore::Data</a> *value) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">As above, but specifying the uniform parameter by name. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIECoreGL_1_1Shader.html#a239e2e3b5cc7cbf5e74161ed7c87218d">setUniformParameterFromVector</a> (GLint parameterIndex, const <a class="el" href="classIECore_1_1Data.html">IECore::Data</a> *vector, unsigned int item)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad5eaae33a6b6ff30449f038cb5329323"></a><!-- doxytag: member="IECoreGL::Shader::setUniformParameterFromVector" ref="ad5eaae33a6b6ff30449f038cb5329323" args="(const std::string &amp;parameterName, const IECore::Data *vector, unsigned int item)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>setUniformParameterFromVector</b> (const std::string &amp;parameterName, const <a class="el" href="classIECore_1_1Data.html">IECore::Data</a> *vector, unsigned int item)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8b8389dd8c698f7d1c4e4b5e876522ee"></a><!-- doxytag: member="IECoreGL::Shader::uniformParameterFromVectorSetup" ref="a8b8389dd8c698f7d1c4e4b5e876522ee" args="(GLint parameterIndex, const IECore::Data *vector) const " -->
VertexToUniform&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIECoreGL_1_1Shader.html#a8b8389dd8c698f7d1c4e4b5e876522ee">uniformParameterFromVectorSetup</a> (GLint parameterIndex, const <a class="el" href="classIECore_1_1Data.html">IECore::Data</a> *vector) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a callable object that sets a uniform shader parameter with a single item value from a given vector. <br/></td></tr>
<tr><td colspan="2"><h2>Static Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Built in shaders</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp8c6ff0af093d1af4c2c7a969073831f6"></a> These functions provide access to static instances of various simple but useful shaders. </p>
<br/><br/></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static ShaderPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIECoreGL_1_1Shader.html#a2fca083e618ae268a97d01b2df2243d4">constant</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac845edb13a441766d7b87ef9c40cc987"></a><!-- doxytag: member="IECoreGL::Shader::facingRatio" ref="ac845edb13a441766d7b87ef9c40cc987" args="()" -->
static ShaderPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIECoreGL_1_1Shader.html#ac845edb13a441766d7b87ef9c40cc987">facingRatio</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a shader which shades as a facing ratio. <br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>A class to represent GLSL shaders. </p>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a419abf697453a4abda11fb887de28aa9"></a><!-- doxytag: member="IECoreGL::Shader::Shader" ref="a419abf697453a4abda11fb887de28aa9" args="(const std::string &amp;vertexSource, const std::string &amp;fragmentSource)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IECoreGL::Shader::Shader </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>vertexSource</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>fragmentSource</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Either vertexSource or fragmentSource may be empty to use the fixed functionality for that shader component. Throws an <a class="el" href="classIECoreGL_1_1Exception.html">Exception</a> if the shader fails to compile, or if the OpenGL version isn't sufficient to support shaders. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="aef1ad01d07573c56d6135be18027e608"></a><!-- doxytag: member="IECoreGL::Shader::bind" ref="aef1ad01d07573c56d6135be18027e608" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void IECoreGL::Shader::bind </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Binds the object into the current OpenGL state in whatever way is relevant to that object (install a shader, make a texture current, enable/disable something etc.). </p>

<p>Implements <a class="el" href="classIECoreGL_1_1Bindable.html#af1a208734db04792a485c9496744fdd2">IECoreGL::Bindable</a>.</p>

</div>
</div>
<a class="anchor" id="a2fca083e618ae268a97d01b2df2243d4"></a><!-- doxytag: member="IECoreGL::Shader::constant" ref="a2fca083e618ae268a97d01b2df2243d4" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static ShaderPtr IECoreGL::Shader::constant </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns a shader which shades as a constant flat color using the current gl color. </p>

</div>
</div>
<a class="anchor" id="a74bfaec9ee0b7c942e062da960be50c9"></a><!-- doxytag: member="IECoreGL::Shader::setUniformParameter" ref="a74bfaec9ee0b7c942e062da960be50c9" args="(const std::string &amp;parameterName, unsigned int textureUnit)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IECoreGL::Shader::setUniformParameter </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>parameterName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>textureUnit</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets the specified sampler parameter to use the texture unit indicated. This call may be slower than the overload based on parameter indexes. </p>

</div>
</div>
<a class="anchor" id="a9c3d244de16b34e65b5bb89b9091681d"></a><!-- doxytag: member="IECoreGL::Shader::setUniformParameter" ref="a9c3d244de16b34e65b5bb89b9091681d" args="(const std::string &amp;parameterName, const IECore::Data *value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IECoreGL::Shader::setUniformParameter </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>parameterName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIECore_1_1Data.html">IECore::Data</a> *&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets the specified parameter to the value specified. value must be of an appropriate type for the parameter - an <a class="el" href="classIECoreGL_1_1Exception.html">Exception</a> is thrown if this is not the case. This call may be slower than the overload based on parameter indexes. </p>

</div>
</div>
<a class="anchor" id="a7cc614ecd21427002d69d61eeea0622d"></a><!-- doxytag: member="IECoreGL::Shader::setUniformParameter" ref="a7cc614ecd21427002d69d61eeea0622d" args="(GLint parameterIndex, const T &amp;value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">boost::disable_if_c&lt; boost::is_convertible&lt; T, <a class="el" href="classIECore_1_1Data.html">IECore::Data</a> * &gt;::value &gt;::type IECoreGL::Shader::setUniformParameter </td>
          <td>(</td>
          <td class="paramtype">GLint&nbsp;</td>
          <td class="paramname"> <em>parameterIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets the specified parameter to the value provided. value must be of an appropriate simple type or a Imath type. </p>

<p>References <a class="el" href="classIECoreGL_1_1Shader.html#a7ea49a456eec79af25ec464b8af33e90">setUniformParameter()</a>, <a class="el" href="classIECore_1_1RunTimeTyped.html#a8f94f94b789f1199b28436a06f1dcab0">IECore::RunTimeTyped::staticTypeId()</a>, and <a class="el" href="classIECoreGL_1_1Shader.html#a21bd15bca3c4f36c7d5a87f35df90fd0">uniformValueValid()</a>.</p>

</div>
</div>
<a class="anchor" id="a7ea49a456eec79af25ec464b8af33e90"></a><!-- doxytag: member="IECoreGL::Shader::setUniformParameter" ref="a7ea49a456eec79af25ec464b8af33e90" args="(GLint parameterIndex, const IECore::Data *value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IECoreGL::Shader::setUniformParameter </td>
          <td>(</td>
          <td class="paramtype">GLint&nbsp;</td>
          <td class="paramname"> <em>parameterIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIECore_1_1Data.html">IECore::Data</a> *&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets the specified uniform parameter to the value specified. value must be of an appropriate type for the parameter - an <a class="el" href="classIECoreGL_1_1Exception.html">Exception</a> is thrown if this is not the case. </p>

<p>Referenced by <a class="el" href="L_2Shader_8h_source.html#l00143">setUniformParameter()</a>.</p>

</div>
</div>
<a class="anchor" id="a239e2e3b5cc7cbf5e74161ed7c87218d"></a><!-- doxytag: member="IECoreGL::Shader::setUniformParameterFromVector" ref="a239e2e3b5cc7cbf5e74161ed7c87218d" args="(GLint parameterIndex, const IECore::Data *vector, unsigned int item)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IECoreGL::Shader::setUniformParameterFromVector </td>
          <td>(</td>
          <td class="paramtype">GLint&nbsp;</td>
          <td class="paramname"> <em>parameterIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIECore_1_1Data.html">IECore::Data</a> *&nbsp;</td>
          <td class="paramname"> <em>vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>item</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets the specified uniform parameter to a single item from a vector Data type. Raises an exception if the type is not compatible. </p>

</div>
</div>
<a class="anchor" id="a446ea1095492b6191e353df01d3f5157"></a><!-- doxytag: member="IECoreGL::Shader::setVertexParameter" ref="a446ea1095492b6191e353df01d3f5157" args="(GLint parameterIndex, const IECore::Data *value, bool normalize=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IECoreGL::Shader::setVertexParameter </td>
          <td>(</td>
          <td class="paramtype">GLint&nbsp;</td>
          <td class="paramname"> <em>parameterIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIECore_1_1Data.html">IECore::Data</a> *&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>normalize</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets the specified vertex parameter to the value specified. value must be of an appropriate type for the parameter - an <a class="el" href="classIECoreGL_1_1Exception.html">Exception</a> is thrown if this is not the case. Derived classes can set normalize to true when they know a integer typed vector should be normalized to [-1,1] or [0,1] when passed to the shader. </p>

</div>
</div>
<a class="anchor" id="a57f96adc255f9308f708212b4acedce8"></a><!-- doxytag: member="IECoreGL::Shader::uniformParameterIndex" ref="a57f96adc255f9308f708212b4acedce8" args="(const std::string &amp;parameterName) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GLint IECoreGL::Shader::uniformParameterIndex </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>parameterName</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns a numeric index for the named uniform parameter. This can be used in the calls below to avoid more expensive lookups by name. Throws an <a class="el" href="classIECoreGL_1_1Exception.html">Exception</a> if parameter does not exist. </p>

</div>
</div>
<a class="anchor" id="a045d1d76de0fff1b9004c8b2b466a8ce"></a><!-- doxytag: member="IECoreGL::Shader::uniformParameterNames" ref="a045d1d76de0fff1b9004c8b2b466a8ce" args="(std::vector&lt; std::string &gt; &amp;names) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IECoreGL::Shader::uniformParameterNames </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::string &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>names</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Uniform Parameters Fills the passed vector with the names of all uniform shader parameters. Structures will use the struct.component convention used in GLSL. Arrays will be returned as a single name, rather than the list array[0], array[n] names used internally in OpenGL. </p>

</div>
</div>
<a class="anchor" id="af1294cfcf9fa9c128413be0a3e66bf2f"></a><!-- doxytag: member="IECoreGL::Shader::uniformParameterType" ref="af1294cfcf9fa9c128413be0a3e66bf2f" args="(GLint parameterIndex) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceIECore.html#af294ec67f3b39230d75efef3844cf448">IECore::TypeId</a> IECoreGL::Shader::uniformParameterType </td>
          <td>(</td>
          <td class="paramtype">GLint&nbsp;</td>
          <td class="paramname"> <em>parameterIndex</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the type of a named uniform parameter, described in terms of the most closely related <a class="el" href="namespaceIECore.html" title="This namespace contains all components of the core library.">IECore</a> datatype. The type here is the type of data returned by the getUniformParameter() function below, except in the case of 2d samplers, where TextureTypeId will be returned. </p>

</div>
</div>
<a class="anchor" id="ad29a9044aa9fa20fbcc4906242579a8d"></a><!-- doxytag: member="IECoreGL::Shader::uniformValueValid" ref="ad29a9044aa9fa20fbcc4906242579a8d" args="(GLint parameterIndex, const IECore::Data *value) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool IECoreGL::Shader::uniformValueValid </td>
          <td>(</td>
          <td class="paramtype">GLint&nbsp;</td>
          <td class="paramname"> <em>parameterIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIECore_1_1Data.html">IECore::Data</a> *&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns true if the specified value is valid for setting the specified uniform parameter, and false if not. </p>

</div>
</div>
<a class="anchor" id="a21bd15bca3c4f36c7d5a87f35df90fd0"></a><!-- doxytag: member="IECoreGL::Shader::uniformValueValid" ref="a21bd15bca3c4f36c7d5a87f35df90fd0" args="(GLint parameterIndex, IECore::TypeId type) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool IECoreGL::Shader::uniformValueValid </td>
          <td>(</td>
          <td class="paramtype">GLint&nbsp;</td>
          <td class="paramname"> <em>parameterIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceIECore.html#af294ec67f3b39230d75efef3844cf448">IECore::TypeId</a>&nbsp;</td>
          <td class="paramname"> <em>type</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns true if the specified data type is valid for setting the specified uniform parameter, and false if not. </p>

<p>Referenced by <a class="el" href="L_2Shader_8h_source.html#l00143">setUniformParameter()</a>.</p>

</div>
</div>
<a class="anchor" id="a1b669db0b38ac64613a18e44e7e3e508"></a><!-- doxytag: member="IECoreGL::Shader::uniformVectorValueValid" ref="a1b669db0b38ac64613a18e44e7e3e508" args="(GLint parameterIndex, const IECore::Data *value) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool IECoreGL::Shader::uniformVectorValueValid </td>
          <td>(</td>
          <td class="paramtype">GLint&nbsp;</td>
          <td class="paramname"> <em>parameterIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIECore_1_1Data.html">IECore::Data</a> *&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns true if the specified vector data is valid for setting one of it's items to the specified uniform parameter, and false if not. </p>

</div>
</div>
<a class="anchor" id="ac6f0cb63d750bda1eff8e76b820b800e"></a><!-- doxytag: member="IECoreGL::Shader::vertexParameterIndex" ref="ac6f0cb63d750bda1eff8e76b820b800e" args="(const std::string &amp;parameterName) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GLint IECoreGL::Shader::vertexParameterIndex </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>parameterName</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns a numeric index for the named vertex parameter. This can be used in the calls below to avoid more expensive lookups by name. Throws an <a class="el" href="classIECoreGL_1_1Exception.html">Exception</a> if parameter does not exist. </p>

</div>
</div>
<a class="anchor" id="ac5ccdf1fabbeb45de97bcb9684570b36"></a><!-- doxytag: member="IECoreGL::Shader::vertexParameterNames" ref="ac5ccdf1fabbeb45de97bcb9684570b36" args="(std::vector&lt; std::string &gt; &amp;names) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IECoreGL::Shader::vertexParameterNames </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::string &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>names</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fills the passed vector with the names of all vertex shader parameters. </p>
<p>Vertex Parameters </p>

</div>
</div>
<a class="anchor" id="aeff90c5c585545a615909b2fa357ac3e"></a><!-- doxytag: member="IECoreGL::Shader::vertexValueValid" ref="aeff90c5c585545a615909b2fa357ac3e" args="(GLint parameterIndex, const IECore::Data *value) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool IECoreGL::Shader::vertexValueValid </td>
          <td>(</td>
          <td class="paramtype">GLint&nbsp;</td>
          <td class="paramname"> <em>parameterIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIECore_1_1Data.html">IECore::Data</a> *&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns true if the specified vertex data object is valid for setting the specified vertex parameter, and false if not. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/IECoreGL/<a class="el" href="L_2Shader_8h_source.html">Shader.h</a></li>
</ul>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&nbsp;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&nbsp;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&nbsp;</span>Friends</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr size="1"/><address style="text-align: right;"><small>Generated on 5 Jan 2012 for Cortex by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
