<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Cortex: Todo List</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.6.1 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<script type="text/javascript">
<!--
function changeDisplayState (e){
  var num=this.id.replace(/[^[0-9]/g,'');
  var button=this.firstChild;
  var sectionDiv=document.getElementById('dynsection'+num);
  if (sectionDiv.style.display=='none'||sectionDiv.style.display==''){
    sectionDiv.style.display='block';
    button.src='open.gif';
  }else{
    sectionDiv.style.display='none';
    button.src='closed.gif';
  }
}
function initDynSections(){
  var divs=document.getElementsByTagName('div');
  var sectionCounter=1;
  for(var i=0;i<divs.length-1;i++){
    if(divs[i].className=='dynheader'&&divs[i+1].className=='dynsection'){
      var header=divs[i];
      var section=divs[i+1];
      var button=header.firstChild;
      if (button!='IMG'){
        divs[i].insertBefore(document.createTextNode(' '),divs[i].firstChild);
        button=document.createElement('img');
        divs[i].insertBefore(button,divs[i].firstChild);
      }
      header.style.cursor='pointer';
      header.onclick=changeDisplayState;
      header.id='dynheader'+sectionCounter;
      button.src='closed.gif';
      section.id='dynsection'+sectionCounter;
      section.style.display='none';
      section.style.marginLeft='14px';
      sectionCounter++;
    }
  }
}
window.onload = initDynSections;
-->
</script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <img id="MSearchSelect" src="search/search.png"
             onmouseover="return searchBox.OnSearchSelectShow()"
             onmouseout="return searchBox.OnSearchSelectHide()"
             alt=""/>
        <input type="text" id="MSearchField" value="Search" accesskey="S"
             onfocus="searchBox.OnSearchFieldFocus(true)" 
             onblur="searchBox.OnSearchFieldFocus(false)" 
             onkeyup="searchBox.OnSearchFieldChange(event)"/>
        <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
        </div>
      </li>
    </ul>
  </div>
</div>
<div class="contents">


<h1><a class="anchor" id="todo">Todo List </a></h1><p><a class="anchor" id="_todo000014"></a> </p>
<dl>
<dt>Group <a class="el" href="classIECore_1_1DeepPixel.html#amgrp25ad821457b727efc9e0bd6e30ed3784">Deep Compositing</a>  </dt>
<dd>: should these be methods or should they go in DeepPixelAlgo.h </dd>
</dl>
<p><a class="anchor" id="_todo000001"></a> </p>
<dl>
<dt>Class <a class="el" href="classIECore_1_1AttributeState.html">IECore::AttributeState</a>  </dt>
<dd>Make order of rendering match order of addition - there are cases where 3delight cares very much what order attributes are specified in (subsurface attributes in particular). </dd>
</dl>
<p><a class="anchor" id="_todo000002"></a> </p>
<dl>
<dt>Class <a class="el" href="classIECore_1_1BGEOParticleReader.html">IECore::BGEOParticleReader</a>  </dt>
<dd>Use id prim var for filtering. </dd>
</dl>
<p><a class="anchor" id="_todo000003"></a> </p>
<dl>
<dt>Member <a class="el" href="classIECore_1_1BoundedKDTree.html#a7a176618a86f836b0e7907b04ec55431">IECore::BoundedKDTree::intersectingBounds</a> (const S &amp;b, std::vector&lt; BoundIterator &gt; &amp;bounds) const  </dt>
<dd>There should be a form where nearNeighbours is an output iterator, to allow any container to be filled. </dd>
</dl>
<p><a class="anchor" id="_todo000006"></a> </p>
<dl>
<dt>Class <a class="el" href="classIECore_1_1CachedReader.html">IECore::CachedReader</a>  </dt>
<dd><p class="startdd">We probably need a way of setting parameters for the Readers, and treating reads with different parameters as different entities in the cache. </p>
<p>Stats on cache misses etc. </p>
<p class="enddd">Can we do something to make sure that two paths to the same file (symlinks) result in only a single cache entry? </p>
</dd>
</dl>
<p><a class="anchor" id="_todo000007"></a> </p>
<dl>
<dt>Member <a class="el" href="classIECore_1_1CapturingRenderer.html#a654b7a8fdda0df14037c8d0ee62fe80c">IECore::CapturingRenderer::world</a> () </dt>
<dd>If we had a class for representing whole Scenes (including stuff before worldBegin) then we could have a scene() method instead. </dd>
</dl>
<p><a class="anchor" id="_todo000061"></a> </p>
<dl>
<dt>Member <a class="el" href="group__python.html#ga4353cbd9f5c0e3975fdf03f7c0063ec2">IECore::cat</a>  </dt>
<dd>Allow destination file to be specified </dd>
</dl>
<p><a class="anchor" id="_todo000008"></a> </p>
<dl>
<dt>Member <a class="el" href="classIECore_1_1ChannelOp.html#ae268c66b7e9b4d4a4408da9e1ac3caf8">IECore::ChannelOp::modifyChannels</a> (const Imath::Box2i &amp;displayWindow, const Imath::Box2i &amp;dataWindow, ChannelVector &amp;channels)=0 </dt>
<dd>ChannelVector doesn't contain any indicator as to which channel is which, so why not just pass a single channel at a time? As things are right now, every derived class is iterating over the channels vector - there's not much else they can do - so it would make sense to move that step to the base class. If we pass a single channel at a time then we could also thread the computation of the different channels. </dd>
</dl>
<p><a class="anchor" id="_todo000009"></a> </p>
<dl>
<dt>Member <a class="el" href="namespaceIECore.html#ab42e7a32a2f8b9e13a144d67f2fffe56">IECore::convert</a> (const F &amp;from) </dt>
<dd>Could this be declared static inline? </dd>
</dl>
<p><a class="anchor" id="_todo000010"></a> </p>
<dl>
<dt>Member <a class="el" href="classIECore_1_1CurvesPrimitiveEvaluator.html#ad1fa7e6295b5165a81402ff9b90980a9">IECore::CurvesPrimitiveEvaluator::create</a> (ConstPrimitivePtr primitive) </dt>
<dd>It would be much better if PrimitiveEvaluator::Description didn't require these create() functions and instead just called the constructors that have to exist anyway. </dd>
</dl>
<p><a class="anchor" id="_todo000011"></a> </p>
<dl>
<dt>Class <a class="el" href="classIECore_1_1DeepImageConverter.html">IECore::DeepImageConverter</a>  </dt>
<dd><p class="startdd">: should this operate on a FileSequence rather than a single file?</p>
<p class="enddd"></p>
</dd>
</dl>
<p><a class="anchor" id="_todo000012"></a> </p>
<dl>
<dt>Member <a class="el" href="classIECore_1_1DeepImageWriter.html#aba1d010dae90aa1aca01a5ee9b561825">IECore::DeepImageWriter::resolutionParameter</a> () </dt>
<dd>: should this be dataWindow or resolution? </dd>
</dl>
<p><a class="anchor" id="_todo000013"></a> </p>
<dl>
<dt>Member <a class="el" href="classIECore_1_1DeepPixel.html#a03e4372e74f03dd93cb2752d4e37053b">IECore::DeepPixel::interpolatedChannelData</a> (float depth, float *result) const  </dt>
<dd>: should there be a parameter for interpolation type, or is linear enough? </dd>
</dl>
<p><a class="anchor" id="_todo000015"></a> </p>
<dl>
<dt>Class <a class="el" href="classIECore_1_1EnvMapSampler.html">IECore::EnvMapSampler</a>  </dt>
<dd><p class="startdd">: use SphericalToEuclideanTransform that is based on right-hand coordinate system. Currently it is left-hand to match 3delight environment light mapping. But maya and nuke and the spherical harmonics implementation in <a class="el" href="namespaceIECore.html" title="This namespace contains all components of the core library.">IECore</a> are right-handed.</p>
<p class="enddd"></p>
</dd>
</dl>
<p><a class="anchor" id="_todo000016"></a> </p>
<dl>
<dt>Class <a class="el" href="classIECore_1_1FileIndexedIO.html">IECore::FileIndexedIO</a>  </dt>
<dd>Most of the implementation of this class would be better of in a "StreamIndexedIO" class which FileIndexedIO and MemoryIndexedIO derive from. MemoryIndexedIO wasn't implemented that cleanly in the first place due to the necessity to maintain binary compatibility. </dd>
</dl>
<p><a class="anchor" id="_todo000018"></a> </p>
<dl>
<dt>Member <a class="el" href="classIECore_1_1FileIndexedIO.html#a71e55f23e4e90b83baf66ddee078f150">IECore::FileIndexedIO::device</a> () </dt>
<dd>Add virtual method to obtain device name ( e.g filename, "memory", etc ) </dd>
</dl>
<p><a class="anchor" id="_todo000017"></a> </p>
<dl>
<dt>Member <a class="el" href="classIECore_1_1FileIndexedIO.html#a1042fc17a611691e71ffb870c09e993b">IECore::FileIndexedIO::flush</a> () </dt>
<dd>Should be virtual </dd>
</dl>
<p><a class="anchor" id="_todo000019"></a> </p>
<dl>
<dt>Class <a class="el" href="classIECore_1_1FileSequenceVectorParameter.html">IECore::FileSequenceVectorParameter</a>  </dt>
<dd>Have this support the specification of frame ranges as well (in a form like "fileName.#.ext 1-20") This should be pretty easy to achieve as the FrameList class already defines the serialisation and parsing for frame ranges. </dd>
</dl>
<p><a class="anchor" id="_todo000020"></a> </p>
<dl>
<dt>Member <a class="el" href="classIECore_1_1Group.html#a00bbe9a3524ba8d0e3420ded19b8c454">IECore::Group::Group</a> () </dt>
<dd>Add a constructor taking a list of children and state and an optional transform, and bind it. </dd>
</dl>
<p><a class="anchor" id="_todo000021"></a> </p>
<dl>
<dt>Class <a class="el" href="classIECore_1_1HdrMergeOp.html">IECore::HdrMergeOp</a>  </dt>
<dd>Take in consideration Alpha channel from input images. </dd>
</dl>
<p><a class="anchor" id="_todo000022"></a> </p>
<dl>
<dt>Class <a class="el" href="classIECore_1_1HierarchicalCache.html">IECore::HierarchicalCache</a>  </dt>
<dd>Create a base class for this one and AttributeCache. </dd>
</dl>
<p><a class="anchor" id="_todo000023"></a> </p>
<dl>
<dt>Class <a class="el" href="classIECore_1_1IFFFile_1_1Chunk.html">IECore::IFFFile::Chunk</a>  </dt>
<dd>: the current implementation only supports reading. It may not be well suited for writing. </dd>
</dl>
<p><a class="anchor" id="_todo000024"></a> </p>
<dl>
<dt>Member <a class="el" href="classIECore_1_1ImageCompositeOp.html#a0294d7a087b35935bf3c8902e35acbfc">IECore::ImageCompositeOp::channelNamesParameter</a> () </dt>
<dd>Create a new base class containing a channelNames parameter, shared with ChannelOp? </dd>
</dl>
<p><a class="anchor" id="_todo000025"></a> </p>
<dl>
<dt>Class <a class="el" href="classIECore_1_1ImagePrimitive.html">IECore::ImagePrimitive</a>  </dt>
<dd><p class="startdd">Define standard depth channel ("Z"? "depth"?) </p>
<p class="enddd">I think we should perhaps rethink the centering of the object space. It seems odd that rendering two images where one has an offset display window should result in them rendering over the top of each other. </p>
</dd>
</dl>
<p><a class="anchor" id="_todo000026"></a> </p>
<dl>
<dt>Member <a class="el" href="classIECore_1_1ImagePrimitive.html#a67aca895ba60a3224be387f7d17bce5d">IECore::ImagePrimitive::ImagePrimitive</a> () </dt>
<dd>Try and make this constructor protected so that only the Object loading can call it. </dd>
</dl>
<p><a class="anchor" id="_todo000027"></a> </p>
<dl>
<dt>Class <a class="el" href="classIECore_1_1InterpolatedCache.html">IECore::InterpolatedCache</a>  </dt>
<dd>It might be great to pass interpolation and oversamples calculator to each read method rather than have them store as state. This would allow different interpolation and oversampling per call and per thread. If we did this I think we should look at replacing the OversamplesCalculator class with some more sensible Time or TimeSampler class, and passing everything in one argument. </dd>
</dl>
<p><a class="anchor" id="_todo000029"></a> </p>
<dl>
<dt>Member <a class="el" href="classIECore_1_1KDTree.html#a64fa750bf4652160b894b891c2758adc">IECore::KDTree::nearestNeighbours</a> (const Point &amp;p, BaseType r, std::vector&lt; PointIterator &gt; &amp;nearNeighbours) const  </dt>
<dd>There should be a form where nearNeighbours is an output iterator, to allow any container to be filled. See enclosedPoints for an example of this form. </dd>
</dl>
<p><a class="anchor" id="_todo000031"></a> </p>
<dl>
<dt>Class <a class="el" href="classIECore_1_1LevenbergMarquardt.html">IECore::LevenbergMarquardt&lt; T, ErrorFn, Traits &gt;</a>  </dt>
<dd><p class="startdd">Use max iterations instead of maxCalls on the error function. </p>
<p>No need for TypedData. Template on vector iterators instead. </p>
<p class="enddd">Consider to pass the parameter changed when building the Jacobian. Most of the problems would not affect all the outputs when just one parameter changes. Some space for considerable optimization there. </p>
</dd>
</dl>
<p><a class="anchor" id="_todo000062"></a> </p>
<dl>
<dt>Class <a class="el" href="classIECore_1_1MenuItemDefinition.html">IECore::MenuItemDefinition</a>  </dt>
<dd>Validation of attribute values, so for instance divider and command can't both be set at the same time. </dd>
</dl>
<p><a class="anchor" id="_todo000032"></a> </p>
<dl>
<dt>Member <a class="el" href="classIECore_1_1MeshPrimitive.html#a98ad97e6f86fe300767607fe0f78208f">IECore::MeshPrimitive::createBox</a> (const Imath::Box3f &amp;b) </dt>
<dd>Add subdivisions and texture coordinates. </dd>
</dl>
<p><a class="anchor" id="_todo000033"></a> </p>
<dl>
<dt>Member <a class="el" href="classIECore_1_1MeshPrimitive.html#a1808889506bac605120a99d1aba983a1">IECore::MeshPrimitive::createPlane</a> (const Imath::Box2f &amp;b) </dt>
<dd>Add subdivisions. </dd>
</dl>
<p><a class="anchor" id="_todo000034"></a> </p>
<dl>
<dt>Class <a class="el" href="classIECore_1_1MeshPrimitiveBuilder.html">IECore::MeshPrimitiveBuilder</a>  </dt>
<dd>This is too specific to MarchingCubes. Some algorithms want to make faces other than triangles, and some algorithms don't want to supply normals. </dd>
</dl>
<p><a class="anchor" id="_todo000036"></a> </p>
<dl>
<dt>Class <a class="el" href="classIECore_1_1MurmurHash.html">IECore::MurmurHash</a>  </dt>
<dd>Deal with endian-ness. </dd>
</dl>
<p><a class="anchor" id="_todo000037"></a> </p>
<dl>
<dt>Class <a class="el" href="classIECore_1_1NURBSPrimitive.html">IECore::NURBSPrimitive</a>  </dt>
<dd>createPlane, createSphere static member functions </dd>
</dl>
<p><a class="anchor" id="_todo000038"></a> </p>
<dl>
<dt>Class <a class="el" href="classIECore_1_1Object_1_1AbstractTypeDescription.html">IECore::Object::AbstractTypeDescription&lt; T &gt;</a>  </dt>
<dd>Hopefully find a way of not needing a separate class for this, but use a specialisation of TypeDescription or summink. </dd>
</dl>
<p><a class="anchor" id="_todo000039"></a> </p>
<dl>
<dt>Member <a class="el" href="classIECore_1_1Op.html#adcb346068dc479f9e8cebeb321b08be9">IECore::Op::doOperation</a> (const CompoundObject *operands)=0 </dt>
<dd>This should be const. </dd>
</dl>
<p><a class="anchor" id="_todo000040"></a> </p>
<dl>
<dt>Class <a class="el" href="classIECore_1_1OversamplesCalculator.html">IECore::OversamplesCalculator</a>  </dt>
<dd>Rename to something more descriptive of its function </dd>
</dl>
<p><a class="anchor" id="_todo000041"></a> </p>
<dl>
<dt>Class <a class="el" href="classIECore_1_1PerlinNoise.html">IECore::PerlinNoise&lt; P, V, F &gt;</a>  </dt>
<dd><p class="startdd">4d ones</p>
<p class="enddd"></p>
</dd>
</dl>
<p><a class="anchor" id="_todo000042"></a> </p>
<dl>
<dt>Class <a class="el" href="classIECore_1_1PointNormalsOp.html">IECore::PointNormalsOp</a>  </dt>
<dd>This was written for a production and then never needed. The normals it produces are somewhat noisy - we could probably do with improving the process. </dd>
</dl>
<p><a class="anchor" id="_todo000043"></a> </p>
<dl>
<dt>Class <a class="el" href="classIECore_1_1PointRepulsionOp.html">IECore::PointRepulsionOp</a>  </dt>
<dd>Class docs </dd>
</dl>
<p><a class="anchor" id="_todo000044"></a> </p>
<dl>
<dt>Member <a class="el" href="classIECore_1_1PointsPrimitiveEvaluator.html#a8d902b08432550625499d435388230b3">IECore::PointsPrimitiveEvaluator::create</a> (ConstPrimitivePtr primitive) </dt>
<dd>It would be much better if PrimitiveEvaluator::Description didn't require these create() functions and instead just called the constructors that have to exist anyway. </dd>
</dl>
<p><a class="anchor" id="_todo000045"></a> </p>
<dl>
<dt>Class <a class="el" href="classIECore_1_1Primitive.html">IECore::Primitive</a>  </dt>
<dd>Validation of variableSizes before rendering. </dd>
</dl>
<p><a class="anchor" id="_todo000047"></a> </p>
<dl>
<dt>Member <a class="el" href="classIECore_1_1PrimitiveEvaluator.html#ab7983f0aed975498f91c3e53a6ca9d6c">IECore::PrimitiveEvaluator::closestPoint</a> (const Imath::V3f &amp;p, Result *result) const =0 </dt>
<dd>Extend this to pass a maximum distance past which results are no longer interesting. </dd>
</dl>
<p><a class="anchor" id="_todo000046"></a> </p>
<dl>
<dt>Member <a class="el" href="classIECore_1_1PrimitiveEvaluator.html#ae79fab312829326a6be0a760f118139f">IECore::PrimitiveEvaluator::signedDistance</a> (const Imath::V3f &amp;p, float &amp;distance) const  </dt>
<dd>: pass a result to this method in major version 6 </dd>
</dl>
<p><a class="anchor" id="_todo000048"></a> </p>
<dl>
<dt>Class <a class="el" href="classIECore_1_1RefCounted.html">IECore::RefCounted</a>  </dt>
<dd>Disallow construction on the heap by having a private destructor - do we need to do this for all derived classes as well? </dd>
</dl>
<p><a class="anchor" id="_todo000060"></a> </p>
<dl>
<dt>Member <a class="el" href="namespaceIECore.html#af7a6644b40edf108c0aa3f4b2cd8d34a">IECore::registerRunTimeTyped</a>  </dt>
<dd>Remove deprecation warning and baseClass parameter on Cortex 6. typId is optional and if not defined, this function will associate a dynamic Id in the range FirstDynamicTypeId and LastDynamicTypeId from TypeIds.h. It's necessary to specify type Id for Object derived class or anything that is serializable. </dd>
</dl>
<p><a class="anchor" id="_todo000064"></a> </p>
<dl>
<dt>Class <a class="el" href="classIECore_1_1RelativePreset.html">IECore::RelativePreset</a>  </dt>
<dd>Consider adding a protected member that is responsible for that comparison and enable derived classes to do other kinds of comparisons, for example, using additional parameters such as user labels. </dd>
</dl>
<p><a class="anchor" id="_todo000051"></a> </p>
<dl>
<dt>Member <a class="el" href="classIECore_1_1Renderer.html#ab72852161207aa3efda6d5c9b692fdd3">IECore::Renderer::image</a> (const Imath::Box2i &amp;dataWindow, const Imath::Box2i &amp;displayWindow, const PrimitiveVariableMap &amp;primVars)=0 </dt>
<dd>Clarify the intended use of dataWindow and displayWindow. </dd>
</dl>
<p><a class="anchor" id="_todo000050"></a> </p>
<dl>
<dt>Member <a class="el" href="classIECore_1_1Renderer.html#a94869f43c647947b0ca88c8b527c2a58">IECore::Renderer::sphere</a> (float radius, float zMin, float zMax, float thetaMax, const PrimitiveVariableMap &amp;primVars)=0 </dt>
<dd>Give this the default values it talks about. </dd>
</dl>
<p><a class="anchor" id="_todo000052"></a> </p>
<dl>
<dt>Class <a class="el" href="classIECore_1_1SpherePrimitiveEvaluator.html">IECore::SpherePrimitiveEvaluator</a>  </dt>
<dd>Currently ignores zMin, zMax, thetaMax parameters, instead assuming that there sphere is whole and facing outwards. </dd>
</dl>
<p><a class="anchor" id="_todo000053"></a> </p>
<dl>
<dt>Class <a class="el" href="classIECore_1_1SphericalHarmonicsRotationMatrix.html">IECore::SphericalHarmonicsRotationMatrix&lt; V &gt;</a>  </dt>
<dd>Current implementation does not take advantage of the matrix sparsity. </dd>
</dl>
<p><a class="anchor" id="_todo000054"></a> </p>
<dl>
<dt>Class <a class="el" href="classIECore_1_1SphericalHarmonicsTransferMatrix.html">IECore::SphericalHarmonicsTransferMatrix&lt; S &gt;</a>  </dt>
<dd>: should consider matrix sparsity. </dd>
</dl>
<p><a class="anchor" id="_todo000055"></a> </p>
<dl>
<dt>Class <a class="el" href="classIECore_1_1SplineToImage.html">IECore::SplineToImage</a>  </dt>
<dd>Different projections would be nice. </dd>
</dl>
<p><a class="anchor" id="_todo000057"></a> </p>
<dl>
<dt>Class <a class="el" href="classIECore_1_1TransformationMatrix.html">IECore::TransformationMatrix&lt; T &gt;</a>  </dt>
<dd>add more utility methods. </dd>
</dl>
<p><a class="anchor" id="_todo000058"></a> </p>
<dl>
<dt>Member <a class="el" href="namespaceIECore.html#a717c0d210f22c639f9208da3ca029291">IECore::triangleArea</a> (const Vec &amp;v0, const Vec &amp;v1, const Vec &amp;v2) </dt>
<dd>It might be nice to make a triangle class and make these methods. </dd>
</dl>
<p><a class="anchor" id="_todo000059"></a> </p>
<dl>
<dt>Class <a class="el" href="classIECore_1_1TriangulateOp.html">IECore::TriangulateOp</a>  </dt>
<dd>Currently we just do a simple "fan" across the face, but we eventually need to deal with concave polygons, polgons with holes, and non-planar polygons </dd>
</dl>
<p><a class="anchor" id="_todo000078"></a> </p>
<dl>
<dt>Class <a class="el" href="classIECoreGL_1_1MeshPrimitive.html">IECoreGL::MeshPrimitive</a>  </dt>
<dd>Fast drawing, uvs etc. Consider using NVIDIA tristrip library? something else? GLU? </dd>
</dl>
<p><a class="anchor" id="_todo000080"></a> </p>
<dl>
<dt>Class <a class="el" href="classIECoreGL_1_1PointsPrimitive.html">IECoreGL::PointsPrimitive</a>  </dt>
<dd>Camera facing seems to fail in orthographic mode. </dd>
</dl>
<p><a class="anchor" id="_todo000081"></a> </p>
<dl>
<dt>Member <a class="el" href="classIECoreGL_1_1PointsPrimitive.html#a53fc39f611dbef1e97ec9acfaee0a926">IECoreGL::PointsPrimitive::Type</a>  </dt>
<dd>We should consider removing the Point enum value and always using the PointsPrimitiveUseGLPoints attribute instead. </dd>
</dl>
<p><a class="anchor" id="_todo000084"></a> </p>
<dl>
<dt>Member <a class="el" href="classIECoreGL_1_1Renderer.html#a67587c2ea783f2a0029341b2ce05cfe6">IECoreGL::Renderer::command</a> (const std::string &amp;name, const <a class="el" href="namespaceIECore.html#ab8801f59558a8c67f526d7c9d730cdda" title="The type of Data held by the CompoundData typedef.">IECore::CompoundDataMap</a> &amp;parameters) </dt>
<dd>Consider generalising an interface for scene edits and making it a standard part of the documentation in <a class="el" href="namespaceIECore.html" title="This namespace contains all components of the core library.">IECore</a>. Any such interface should take into account support for PRMan's new rerendering API. </dd>
</dl>
<p><a class="anchor" id="_todo000083"></a> </p>
<dl>
<dt>Member <a class="el" href="classIECoreGL_1_1Renderer.html#ac400555b5fa076f374b9ce54b48817f0">IECoreGL::Renderer::mesh</a> (IECore::ConstIntVectorDataPtr vertsPerFace, IECore::ConstIntVectorDataPtr vertIds, const std::string &amp;interpolation, const <a class="el" href="namespaceIECore.html#a8831a05758aad0cc4f1968f74afdffca" title="A simple type to hold named PrimitiveVariables.">IECore::PrimitiveVariableMap</a> &amp;primVars) </dt>
<dd>Support normals and st. </dd>
</dl>
<p><a class="anchor" id="_todo000082"></a> </p>
<dl>
<dt>Member <a class="el" href="classIECoreGL_1_1Renderer.html#ac6134c40f82af161fcb95ec2a8a68068">IECoreGL::Renderer::shader</a> (const std::string &amp;type, const std::string &amp;name, const <a class="el" href="namespaceIECore.html#ab8801f59558a8c67f526d7c9d730cdda" title="The type of Data held by the CompoundData typedef.">IECore::CompoundDataMap</a> &amp;parameters) </dt>
<dd>Add support for "textureParameterName:filter" and "textureParameterName:wrap" parameters which set wrapping and filtering on a ShaderStateComponent. </dd>
</dl>
<p><a class="anchor" id="_todo000086"></a> </p>
<dl>
<dt>Class <a class="el" href="classIECoreGL_1_1ShaderStateComponent.html">IECoreGL::ShaderStateComponent</a>  </dt>
<dd>Allow this to specify texture filtering and wrap modes. </dd>
</dl>
<p><a class="anchor" id="_todo000088"></a> </p>
<dl>
<dt>Class <a class="el" href="classIECoreGL_1_1StateComponent.html">IECoreGL::StateComponent</a>  </dt>
<dd>We shouldn't be using TypeId objects for the StateComponent identifiers - we should use summink else (we need to have a Shader and a FixedShader component that both occupy the same slot). </dd>
</dl>
<p><a class="anchor" id="_todo000089"></a> </p>
<dl>
<dt>Class <a class="el" href="classIECoreGL_1_1Texture.html">IECoreGL::Texture</a>  </dt>
<dd>Provide some control over resizing (to power of 2), mipmapping, filtering etc. Rather than complicate the constructors in the subclasses we should probabaly make ToGLTextureConverters with a bunch of parameters. </dd>
</dl>
<p><a class="anchor" id="_todo000090"></a> </p>
<dl>
<dt>Class <a class="el" href="classIECoreGL_1_1TextureLoader.html">IECoreGL::TextureLoader</a>  </dt>
<dd>At some point we'll need to deal with the fact that there's limited texture memory and we can't just keep loading things forever without getting rid of something. </dd>
</dl>
<p><a class="anchor" id="_todo000091"></a> </p>
<dl>
<dt>Class <a class="el" href="classIECoreGL_1_1ToGLConverter.html">IECoreGL::ToGLConverter</a>  </dt>
<dd>Some sort of factory mechanism accepting the desired source and destination types. </dd>
</dl>
<p><a class="anchor" id="_todo000092"></a> </p>
<dl>
<dt>Member <a class="el" href="namespaceIECoreGL.html#adf13b8816d109f912ed3867c8fe8d6c5">IECoreGL::TransparentShadingStateComponent</a>  </dt>
<dd>Consider also moving the following state components to Primitive header since the renderer maps then to "gl:primitive:*" Used to signify that the shading for a primitive may produce transparent values. The Renderer maps the "gl:shade:transparent" attribute directly to this state. Note that this information is provided as a separate state item rather than as a query on the Shader class as the values of variables on Primitives may change the transparency of a shader. </dd>
</dl>
<p><a class="anchor" id="_todo000141"></a> </p>
<dl>
<dt>Member <a class="el" href="classIECoreHoudini_1_1ActiveTake.html#a4e8b42edcf36c5fedaf685d6740d7f5e">IECoreHoudini::ActiveTake::ls</a>  </dt>
<dd>: remove this method when the hscript take commands are available in python </dd>
</dl>
<p><a class="anchor" id="_todo000140"></a> </p>
<dl>
<dt>Member <a class="el" href="classIECoreHoudini_1_1ActiveTake.html#afdc0d4a376200fa395ca9c0e6358dafe">IECoreHoudini::ActiveTake::name</a>  </dt>
<dd>: remove this method when the hscript take commands are available in python </dd>
</dl>
<p><a class="anchor" id="_todo000134"></a> </p>
<dl>
<dt>Member <a class="el" href="classIECoreHoudini_1_1GEO__CobIOTranslator.html#a9d1bff465062e85af1f670597081becf">IECoreHoudini::GEO_CobIOTranslator::fileSave</a> (const GEO_Detail *geo, ostream &amp;os) </dt>
<dd>: Houdini 10 requires that this definition exist, even though it isn't used </dd>
</dl>
<p><a class="anchor" id="_todo000135"></a> </p>
<dl>
<dt>Class <a class="el" href="classIECoreHoudini_1_1RATDeepImageReader.html">IECoreHoudini::RATDeepImageReader</a>  </dt>
<dd><p class="startdd">: add support for arbitrary channels</p>
<p class="enddd"></p>
</dd>
</dl>
<p><a class="anchor" id="_todo000136"></a> </p>
<dl>
<dt>Class <a class="el" href="classIECoreHoudini_1_1RATDeepImageWriter.html">IECoreHoudini::RATDeepImageWriter</a>  </dt>
<dd><p class="startdd">: verify that arbitrary channels can be written once the RATDeepImageReader supports reading them.</p>
<p class="enddd"></p>
</dd>
</dl>
<p><a class="anchor" id="_todo000137"></a> </p>
<dl>
<dt>Class <a class="el" href="classIECoreHoudini_1_1SOP__InterpolatedCacheReader.html">IECoreHoudini::SOP_InterpolatedCacheReader</a>  </dt>
<dd>: allow PrimitiveAttribs to be created based on GB_PrimGroups </dd>
</dl>
<p><a class="anchor" id="_todo000138"></a> </p>
<dl>
<dt>Member <a class="el" href="classIECoreHoudini_1_1SOP__ParameterisedHolder.html#a10af3a6d0de9bb604b46497d262a3a61">IECoreHoudini::SOP_ParameterisedHolder::buildClassCategoryMenu</a> (void *data, PRM_Name *menu, int maxSize, const PRM_SpareData *, PRM_Parm *) </dt>
<dd>: the concept of class category is a hack to make the UI usable. remove this when Houdini supports cascading menus for parameters. </dd>
</dl>
<p><a class="anchor" id="_todo000093"></a> </p>
<dl>
<dt>Class <a class="el" href="classIECoreMaya_1_1CacheSet.html">IECoreMaya::CacheSet</a>  </dt>
<dd>This is an IE specific base class - remove from Cortex </dd>
</dl>
<p><a class="anchor" id="_todo000109"></a> </p>
<dl>
<dt>Class <a class="el" href="classIECoreMaya_1_1DAGPathParameter.html">IECoreMaya::DAGPathParameter</a>  </dt>
<dd>Dervive from IECoreMaya.NodeParameter </dd>
</dl>
<p><a class="anchor" id="_todo000118"></a> </p>
<dl>
<dt>Class <a class="el" href="classIECoreMaya_1_1DAGPathParameter_1_1CheckType.html">IECoreMaya::DAGPathParameter::CheckType</a>  </dt>
<dd>Use Enum for this </dd>
</dl>
<p><a class="anchor" id="_todo000094"></a> </p>
<dl>
<dt>Class <a class="el" href="classIECoreMaya_1_1FromMayaMeshConverter.html">IECoreMaya::FromMayaMeshConverter</a>  </dt>
<dd>Vertex color support. Blind data support? </dd>
</dl>
<p><a class="anchor" id="_todo000095"></a> </p>
<dl>
<dt>Member <a class="el" href="classIECoreMaya_1_1FromMayaMeshConverter.html#a47eb2089b1bc3c7ad0d380f430f3a1b1">IECoreMaya::FromMayaMeshConverter::points</a> () const  </dt>
<dd>It would be nice if this was virtual somewhere and implemented for other converters for which it makes sense. I'm not sure it belongs in the FromMayaShapeConverter though. </dd>
</dl>
<p><a class="anchor" id="_todo000096"></a> </p>
<dl>
<dt>Class <a class="el" href="classIECoreMaya_1_1MayaAppendIterator.html">IECoreMaya::MayaAppendIterator&lt; T &gt;</a>  </dt>
<dd>Should this be a member of MArrayIter? </dd>
</dl>
<p><a class="anchor" id="_todo000117"></a> </p>
<dl>
<dt>Class <a class="el" href="classIECoreMaya_1_1NodeParameter_1_1CheckType.html">IECoreMaya::NodeParameter::CheckType</a>  </dt>
<dd>Use Enum for this </dd>
</dl>
<p><a class="anchor" id="_todo000097"></a> </p>
<dl>
<dt>Class <a class="el" href="classIECoreMaya_1_1ObjectData.html">IECoreMaya::ObjectData</a>  </dt>
<dd>Perhaps offer this as a template instead, to allow specific classes of objects to be held in their own data type entirely. Maya would then prevent connection between incompatible types. </dd>
</dl>
<p><a class="anchor" id="_todo000112"></a> </p>
<dl>
<dt>Class <a class="el" href="classIECoreMaya_1_1OpWindow.html">IECoreMaya::OpWindow</a>  </dt>
<dd>We need to close this window if the node is deleted - for instance when the user makes a fresh scene. </dd>
</dl>
<p><a class="anchor" id="_todo000098"></a> </p>
<dl>
<dt>Member <a class="el" href="classIECoreMaya_1_1ParameterisedHolderInterface.html#afd0da7fbdece58701d1e031eea80f6ab">IECoreMaya::ParameterisedHolderInterface::getParameterisedInterface</a> (std::string *className, int *classVersion=0, std::string *searchPathEnvVar=0) </dt>
<dd>Remove version with no arguments and default className to 0 as well. </dd>
</dl>
<p><a class="anchor" id="_todo000111"></a> </p>
<dl>
<dt>Class <a class="el" href="classIECoreMaya_1_1ParameterPanel.html">IECoreMaya::ParameterPanel</a>  </dt>
<dd><p class="startdd">Reimplement this in terms of the new Panel base class. </p>
<p class="enddd">Prefix methods which aren't intended to be public to make them either private or protected. </p>
</dd>
</dl>
<p><a class="anchor" id="_todo000108"></a> </p>
<dl>
<dt>Class <a class="el" href="classIECoreMaya_1_1ParameterUI.html">IECoreMaya::ParameterUI</a>  </dt>
<dd>Separate control drawing from labelling and layout, so these classes just create the right hand side of what they're doing at the moment. Then we can use them in different layouts like spreadsheets and wotnot. </dd>
</dl>
<p><a class="anchor" id="_todo000114"></a> </p>
<dl>
<dt>Member <a class="el" href="classIECoreMaya_1_1ParameterUI.html#ac6b4811e1e61185c307262755da4eb1a">IECoreMaya::ParameterUI::__init__</a>  </dt>
<dd>Document the meaning of the various keyword arguments - perhaps the names of these should be prefixed with the name of the class which implements each argument so as to make it easier to find the documentation too. </dd>
</dl>
<p><a class="anchor" id="_todo000100"></a> </p>
<dl>
<dt>Class <a class="el" href="classIECoreMaya_1_1PythonCmd.html">IECoreMaya::PythonCmd</a>  </dt>
<dd><p class="startdd">Support the conversion of -eval results into the most appropriate mel form based on type </p>
<p class="enddd">Split the management of python contexts and all the evaluation code into a Python object defined in an IECorePython library. Then we can use that object in a Nuke python plugin and wherever else we want. And this command becomes a lot smaller and easier to maintain. Nice. </p>
</dd>
</dl>
<p><a class="anchor" id="_todo000110"></a> </p>
<dl>
<dt>Class <a class="el" href="classIECoreMaya_1_1ScopedSelection.html">IECoreMaya::ScopedSelection</a>  </dt>
<dd><p class="startdd">Cope with objects changing names, being deleted etc - can probably do this by storing DagNode and Node objects. </p>
<p class="enddd">This should be reimplemented as a context object called SelectionSaved to follow the model set by UndoDisabled. </p>
</dd>
</dl>
<p><a class="anchor" id="_todo000113"></a> </p>
<dl>
<dt>Class <a class="el" href="classIECoreMaya_1_1StringVectorParameterUI.html">IECoreMaya::StringVectorParameterUI</a>  </dt>
<dd>: this is incredibly similar to NumericVectorParameterUI. Is it possible to generalize a ParameterUI for all *VectorParameters? </dd>
</dl>
<p><a class="anchor" id="_todo000101"></a> </p>
<dl>
<dt>Member <a class="el" href="classIECoreMaya_1_1ToMayaObjectConverter.html#af762202450164ea3d3a60802e0bd9a0d">IECoreMaya::ToMayaObjectConverter::convert</a> (MObject &amp;object) const  </dt>
<dd>Define the meaning of object. Some derived classes seem to modify it, others seem to create a new one and assign it. I think if a valid object is passed then it should be edited, and if a null object is passed then a new one should be created. We also probably need a ToMayaShapeConverter base class with some parentOrOwner type semantics. </dd>
</dl>
<p><a class="anchor" id="_todo000102"></a> </p>
<dl>
<dt>Member <a class="el" href="classIECoreMaya_1_1ToMayaObjectConverter_1_1ToMayaObjectConverterDescription.html#a94e3b0d3d203201aa71906aff3011906">IECoreMaya::ToMayaObjectConverter::ToMayaObjectConverterDescription::ToMayaObjectConverterDescription</a> (<a class="el" href="namespaceIECore.html#af294ec67f3b39230d75efef3844cf448">IECore::TypeId</a> fromType, const MFn::Type resultType) </dt>
<dd>Constructors allowing more complex mappings of types (multiple fromTypes and resultTypes). </dd>
</dl>
<p><a class="anchor" id="_todo000103"></a> </p>
<dl>
<dt>Class <a class="el" href="classIECoreMaya_1_1ToMayaParticleConverter.html">IECoreMaya::ToMayaParticleConverter</a>  </dt>
<dd>Could we make a ToMayaShapeConverter base class to provide utilities for this and the ToMayaMeshConverter etc? </dd>
</dl>
<p><a class="anchor" id="_todo000104"></a> </p>
<dl>
<dt>Member <a class="el" href="classIECoreMaya_1_1ToMayaPlugConverter.html#a459b021bcafe6f2daecbee70e78ef831">IECoreMaya::ToMayaPlugConverter::convert</a> (MPlug &amp;plug) const  </dt>
<dd>Replace this function with one that calls a pure virtual doConversion function taking the contents of parameters(), like the other converters. Also consider that MStatus might be a better return type, and that we might also want a converter to create a new plug rather than just fill an existing one. </dd>
</dl>
<p><a class="anchor" id="_todo000105"></a> </p>
<dl>
<dt>Member <a class="el" href="classIECoreMaya_1_1ToMayaPlugConverter.html#ab8f59f482c157aed309733e04bdeb717">IECoreMaya::ToMayaPlugConverter::create</a> (const IECore::ObjectPtr src) </dt>
<dd><p class="startdd">Implement this as a genuine factory which creates subclasses. </p>
<p class="enddd">Should be ConstPtr not const Ptr. </p>
</dd>
</dl>
<p><a class="anchor" id="_todo000106"></a> </p>
<dl>
<dt>Class <a class="el" href="classIECoreMaya_1_1TransformationMatrixParameterHandler.html">IECoreMaya::TransformationMatrixParameterHandler&lt; T &gt;</a>  </dt>
<dd>Expose and add support for other rotation orders supported by Imath::Euler&lt;T&gt; </dd>
</dl>
<p><a class="anchor" id="_todo000107"></a> </p>
<dl>
<dt>Class <a class="el" href="classIECoreMaya_1_1UIElement.html">IECoreMaya::UIElement</a>  </dt>
<dd>Preexisting ui elements should be rewritten to take advantage of this base class wherever possible. </dd>
</dl>
<p><a class="anchor" id="_todo000074"></a> </p>
<dl>
<dt>Class <a class="el" href="classIECoreNuke_1_1FromNukePointsConverter.html">IECoreNuke::FromNukePointsConverter</a>  </dt>
<dd>Might be good to have a FromNukeGeometryConverter as a base class of this and MeshFromNuke. . </dd>
</dl>
<p><a class="anchor" id="_todo000075"></a> </p>
<dl>
<dt>Class <a class="el" href="classIECoreNuke_1_1MeshFromNuke.html">IECoreNuke::MeshFromNuke</a>  </dt>
<dd>Sort out the naming of this and other converters so they follow the convention used elsewhere in cortex - particularly <a class="el" href="namespaceIECoreMaya.html" title="The IECoreMaya namespace holds all the functionality of libIECoreMaya.">IECoreMaya</a>. </dd>
</dl>
<p><a class="anchor" id="_todo000076"></a> </p>
<dl>
<dt>Class <a class="el" href="classIECoreNuke_1_1MeshToNukeGeometryConverter.html">IECoreNuke::MeshToNukeGeometryConverter</a>  </dt>
<dd>Sort out the naming of this and other converters so they follow the convention used elsewhere in cortex - particularly <a class="el" href="namespaceIECoreMaya.html" title="The IECoreMaya namespace holds all the functionality of libIECoreMaya.">IECoreMaya</a>. . </dd>
</dl>
<p><a class="anchor" id="_todo000077"></a> </p>
<dl>
<dt>Member <a class="el" href="classIECoreNuke_1_1OpHolder.html#af927074c33b4e53d60496a580b1b476b">IECoreNuke::OpHolder::isExecuteThreadSafe</a> () const  </dt>
<dd>We /are/ threadsafe, but Nuke doesn't release the GIL when calling through to here from nuke.execute(). We therefore have to pretend not to be threadsafe - if they fix this we can return true from this instead of false. </dd>
</dl>
<p><a class="anchor" id="_todo000067"></a> </p>
<dl>
<dt>Namespace <a class="el" href="namespaceIECoreRI.html">IECoreRI</a>  </dt>
<dd>Can this include be relocated so you don't need a direct dependency on 3Delight in the consuming code? </dd>
</dl>
<p><a class="anchor" id="_todo000068"></a> </p>
<dl>
<dt>Class <a class="el" href="classIECoreRI_1_1GXEvaluator.html">IECoreRI::GXEvaluator</a>  </dt>
<dd>Can we make this refcounted? It will help simplify most threaded implementations. </dd>
</dl>
<p><a class="anchor" id="_todo000069"></a> </p>
<dl>
<dt>Member <a class="el" href="classIECoreRI_1_1Renderer.html#a31d49ca667775a476729831d775a50e6">IECoreRI::Renderer::camera</a> (const std::string &amp;name, const <a class="el" href="namespaceIECore.html#ab8801f59558a8c67f526d7c9d730cdda" title="The type of Data held by the CompoundData typedef.">IECore::CompoundDataMap</a> &amp;parameters) </dt>
<dd>Support moving cameras, and named cameras using RiCamera. </dd>
</dl>
<p><a class="anchor" id="_todo000073"></a> </p>
<dl>
<dt>Member <a class="el" href="classIECoreRI_1_1Renderer.html#a179b54fef6eb51e0135bbb51e2f66fd7">IECoreRI::Renderer::command</a> (const std::string &amp;name, const <a class="el" href="namespaceIECore.html#ab8801f59558a8c67f526d7c9d730cdda" title="The type of Data held by the CompoundData typedef.">IECore::CompoundDataMap</a> &amp;parameters) </dt>
<dd><p class="startdd">Make a VisibleRenderable subclass to encapsulate a call to this.</p>
<p class="enddd"></p>
</dd>
</dl>
<p><a class="anchor" id="_todo000072"></a> </p>
<dl>
<dt>Member <a class="el" href="classIECoreRI_1_1Renderer.html#a4228ed06e2260009861b50d787d89427">IECoreRI::Renderer::mesh</a> (IECore::ConstIntVectorDataPtr vertsPerFace, IECore::ConstIntVectorDataPtr vertIds, const std::string &amp;interpolation, const <a class="el" href="namespaceIECore.html#a8831a05758aad0cc4f1968f74afdffca" title="A simple type to hold named PrimitiveVariables.">IECore::PrimitiveVariableMap</a> &amp;primVars) </dt>
<dd>Consider how we might standardise a means of storing tags explicitly on the mesh rather than as primitive variables. </dd>
</dl>
<p><a class="anchor" id="_todo000070"></a> </p>
<dl>
<dt>Member <a class="el" href="classIECoreRI_1_1Renderer.html#a03376dc5280cee9f5bde9575bf2ec40e">IECoreRI::Renderer::setAttribute</a> (const std::string &amp;name, IECore::ConstDataPtr value) </dt>
<dd><p class="startdd">Do the todo items in <a class="el" href="classIECore_1_1Group.html">IECore::Group</a> and <a class="el" href="classIECore_1_1AttributeState.html">IECore::AttributeState</a> and deprecate the ri:subsurface call.</p>
<p></p>
<p class="enddd">Consider whether or not we should have a standard LOD mechanism defined in <a class="el" href="namespaceIECore.html" title="This namespace contains all components of the core library.">IECore</a>. </p>
</dd>
</dl>
<p><a class="anchor" id="_todo000130"></a> </p>
<dl>
<dt>Member <a class="el" href="ieParameterisedHolder_8mel.html#acfa594c6144a051728d392699ca5fcc7">ieParameterisedHolderClassName</a>  </dt>
<dd>Handle case where getParameterised() returns None </dd>
</dl>
<p><a class="anchor" id="_todo000132"></a> </p>
<dl>
<dt>Member <a class="el" href="ieParameterisedHolder_8mel.html#abe6582edd7a3e3a7189a475500017bb4">ieParameterisedHolderClassSearchPathEnvVar</a>  </dt>
<dd>Handle case where getParameterised() returns None </dd>
</dl>
<p><a class="anchor" id="_todo000131"></a> </p>
<dl>
<dt>Member <a class="el" href="ieParameterisedHolder_8mel.html#afe1cb0ff492a643768400063dddd39b4">ieParameterisedHolderClassVersion</a>  </dt>
<dd>Handle case where getParameterised() returns None </dd>
</dl>
<p><a class="anchor" id="_todo000049"></a> </p>
<dl>
<dt>Group <a class="el" href="classIECore_1_1Renderer.html#amgrp6f1b10c83f41962b7bc970aa1514f337">Primitives</a>  </dt>
<dd>Better documentation for the calls below, particularly in relation to the rightHandedOrientation attribute. </dd>
</dl>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&nbsp;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&nbsp;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&nbsp;</span>Friends</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr size="1"/><address style="text-align: right;"><small>Generated on 5 Jan 2012 for Cortex by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
