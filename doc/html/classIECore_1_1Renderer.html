<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Cortex: IECore::Renderer Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.6.1 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<script type="text/javascript">
<!--
function changeDisplayState (e){
  var num=this.id.replace(/[^[0-9]/g,'');
  var button=this.firstChild;
  var sectionDiv=document.getElementById('dynsection'+num);
  if (sectionDiv.style.display=='none'||sectionDiv.style.display==''){
    sectionDiv.style.display='block';
    button.src='open.gif';
  }else{
    sectionDiv.style.display='none';
    button.src='closed.gif';
  }
}
function initDynSections(){
  var divs=document.getElementsByTagName('div');
  var sectionCounter=1;
  for(var i=0;i<divs.length-1;i++){
    if(divs[i].className=='dynheader'&&divs[i+1].className=='dynsection'){
      var header=divs[i];
      var section=divs[i+1];
      var button=header.firstChild;
      if (button!='IMG'){
        divs[i].insertBefore(document.createTextNode(' '),divs[i].firstChild);
        button=document.createElement('img');
        divs[i].insertBefore(button,divs[i].firstChild);
      }
      header.style.cursor='pointer';
      header.onclick=changeDisplayState;
      header.id='dynheader'+sectionCounter;
      button.src='closed.gif';
      section.id='dynsection'+sectionCounter;
      section.style.display='none';
      section.style.marginLeft='14px';
      sectionCounter++;
    }
  }
}
window.onload = initDynSections;
-->
</script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <img id="MSearchSelect" src="search/search.png"
             onmouseover="return searchBox.OnSearchSelectShow()"
             onmouseout="return searchBox.OnSearchSelectHide()"
             alt=""/>
        <input type="text" id="MSearchField" value="Search" accesskey="S"
             onfocus="searchBox.OnSearchFieldFocus(true)" 
             onblur="searchBox.OnSearchFieldFocus(false)" 
             onkeyup="searchBox.OnSearchFieldChange(event)"/>
        <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
        </div>
      </li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="namespaceIECore.html">IECore</a>::<a class="el" href="classIECore_1_1Renderer.html">Renderer</a>
  </div>
</div>
<div class="contents">
<h1>IECore::Renderer Class Reference<br/>
<small>
[<a class="el" href="group__renderingGroup.html">Rendering</a>]</small>
</h1><!-- doxytag: class="IECore::Renderer" --><!-- doxytag: inherits="IECore::RunTimeTyped" -->
<p><code>#include &lt;<a class="el" href="Renderer_8h_source.html">Renderer.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for IECore::Renderer:</div>
<div class="dynsection">
 <div class="center">
  <img src="classIECore_1_1Renderer.gif" usemap="#IECore::Renderer_map" alt=""/>
  <map id="IECore::Renderer_map" name="IECore::Renderer_map">
<area href="classIECore_1_1RunTimeTyped.html" alt="IECore::RunTimeTyped" shape="rect" coords="175,56,340,80"/>
<area href="classIECore_1_1RefCounted.html" alt="IECore::RefCounted" shape="rect" coords="175,0,340,24"/>
<area href="classIECore_1_1CapturingRenderer.html" alt="IECore::CapturingRenderer" shape="rect" coords="0,168,165,192"/>
<area href="classIECoreGL_1_1Renderer.html" alt="IECoreGL::Renderer" shape="rect" coords="175,168,340,192"/>
<area href="classIECoreRI_1_1Renderer.html" alt="IECoreRI::Renderer" shape="rect" coords="350,168,515,192"/>
</map>
 </div>
</div>

<p><a href="classIECore_1_1Renderer-members.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIECore_1_1Renderer_1_1Procedural.html">Procedural</a></td></tr>
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4838749d83f52cbb3f367cb4ef13e059"></a><!-- doxytag: member="IECore::Renderer::IE_CORE_DECLARERUNTIMETYPED" ref="a4838749d83f52cbb3f367cb4ef13e059" args="(Renderer, RunTimeTyped)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><b>IE_CORE_DECLARERUNTIMETYPED</b> (<a class="el" href="classIECore_1_1Renderer.html">Renderer</a>, <a class="el" href="classIECore_1_1RunTimeTyped.html">RunTimeTyped</a>)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIECore_1_1Renderer.html#a3faf858c0be8b8d54950c25bc5c15429">camera</a> (const std::string &amp;name, const <a class="el" href="namespaceIECore.html#ab8801f59558a8c67f526d7c9d730cdda">CompoundDataMap</a> &amp;parameters)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIECore_1_1Renderer.html#a6701d3d585217ccdac915ac300b81130">display</a> (const std::string &amp;name, const std::string &amp;type, const std::string &amp;data, const <a class="el" href="namespaceIECore.html#ab8801f59558a8c67f526d7c9d730cdda">CompoundDataMap</a> &amp;parameters)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abc59d41232f26fd1b76d0eecb9a0f8dc"></a><!-- doxytag: member="IECore::Renderer::IE_CORE_DECLAREPTR" ref="abc59d41232f26fd1b76d0eecb9a0f8dc" args="(Procedural)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><b>IE_CORE_DECLAREPTR</b> (<a class="el" href="classIECore_1_1Renderer_1_1Procedural.html">Procedural</a>)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad653dcca5715d314a323eb7f81577ed3"></a><!-- doxytag: member="IECore::Renderer::procedural" ref="ad653dcca5715d314a323eb7f81577ed3" args="(ProceduralPtr proc)=0" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIECore_1_1Renderer.html#ad653dcca5715d314a323eb7f81577ed3">procedural</a> (ProceduralPtr proc)=0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Renders a piece of procedural geometry. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual DataPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIECore_1_1Renderer.html#af6002d21ab8243698183b8f4b7db1ae8">command</a> (const std::string &amp;name, const <a class="el" href="namespaceIECore.html#ab8801f59558a8c67f526d7c9d730cdda">CompoundDataMap</a> &amp;parameters)=0</td></tr>
<tr><td colspan="2"><div class="groupHeader">Options</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrpdae8ace18bdcbcc6ae5aece263e14fe8"></a> Options are named items of data which control some global aspect of the render. These functions allow their setting and getting. All options must be set before a call to <a class="el" href="classIECore_1_1Renderer.html#ae525ed886ed90f3286c412d3c3ad1503">worldBegin()</a> - it is invalid to change an option after <a class="el" href="classIECore_1_1Renderer.html#ae525ed886ed90f3286c412d3c3ad1503">worldBegin()</a>.</p>
<dl class="user"><dt><b>Standard SearchPath Options</b></dt><dd><br/>
 <ul>
<li><b>"searchPath:font" StringData</b><br/>
 A colon separated list of paths to search for fonts on - these are used by the <a class="el" href="classIECore_1_1Renderer.html#ab6d5b5b38e65aaaafe14e911b154767b" title="Renders some text.">text()</a> primitive. The default value should come from the IECORE_FONT_PATHS environment variable if set. </li>
</ul>
</dd></dl>
<br/><br/></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acd834661ea7c64c6987bfa660d08f650"></a><!-- doxytag: member="IECore::Renderer::setOption" ref="acd834661ea7c64c6987bfa660d08f650" args="(const std::string &amp;name, ConstDataPtr value)=0" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIECore_1_1Renderer.html#acd834661ea7c64c6987bfa660d08f650">setOption</a> (const std::string &amp;name, ConstDataPtr value)=0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set an option. Must not be called after <a class="el" href="classIECore_1_1Renderer.html#ae525ed886ed90f3286c412d3c3ad1503">worldBegin()</a>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afb061a62ae6caea078606f681bc62b2b"></a><!-- doxytag: member="IECore::Renderer::getOption" ref="afb061a62ae6caea078606f681bc62b2b" args="(const std::string &amp;name) const =0" -->
virtual ConstDataPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIECore_1_1Renderer.html#afb061a62ae6caea078606f681bc62b2b">getOption</a> (const std::string &amp;name) const =0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the value of a previously set option. <br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">World block</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp368c258770649e89dbdde9599dc53bfa"></a> Once all options, cameras and displays are specified, a world block is created in which the visible elements of the scene are described. </p>
<br/><br/></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIECore_1_1Renderer.html#ae525ed886ed90f3286c412d3c3ad1503">worldBegin</a> ()=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a29e5ea49563295e9650fa97de4283378"></a><!-- doxytag: member="IECore::Renderer::worldEnd" ref="a29e5ea49563295e9650fa97de4283378" args="()=0" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIECore_1_1Renderer.html#a29e5ea49563295e9650fa97de4283378">worldEnd</a> ()=0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Finishes the world block. <br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Transforms</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp5e5aa5cf1b19396842f8d82f26038065"></a> The <a class="el" href="classIECore_1_1Renderer.html">Renderer</a> manages a hierarchical set of transforms, applying the current transform to all cameras and primitives that are created. </p>
<br/><br/></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIECore_1_1Renderer.html#a8de999de675f13ad6b0c75aef9507508">transformBegin</a> ()=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a720c43eccd8e823aa52e4e810bc2b479"></a><!-- doxytag: member="IECore::Renderer::transformEnd" ref="a720c43eccd8e823aa52e4e810bc2b479" args="()=0" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIECore_1_1Renderer.html#a720c43eccd8e823aa52e4e810bc2b479">transformEnd</a> ()=0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns to the transform state saved by the last <a class="el" href="classIECore_1_1Renderer.html#a8de999de675f13ad6b0c75aef9507508">transformBegin()</a> call. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a58f35baba6120c16de72e7e25c9c9fc1"></a><!-- doxytag: member="IECore::Renderer::setTransform" ref="a58f35baba6120c16de72e7e25c9c9fc1" args="(const Imath::M44f &amp;m)=0" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIECore_1_1Renderer.html#a58f35baba6120c16de72e7e25c9c9fc1">setTransform</a> (const Imath::M44f &amp;m)=0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the current transform. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIECore_1_1Renderer.html#ae40039c9e135edc5250f9ab709af56d5">setTransform</a> (const std::string &amp;coordinateSystem)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acfbbabaa4828dd2298b9967cdbf9b790"></a><!-- doxytag: member="IECore::Renderer::getTransform" ref="acfbbabaa4828dd2298b9967cdbf9b790" args="() const =0" -->
virtual Imath::M44f&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIECore_1_1Renderer.html#acfbbabaa4828dd2298b9967cdbf9b790">getTransform</a> () const =0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the current transform. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1517ef18a8405133b722b4ee892ebed6"></a><!-- doxytag: member="IECore::Renderer::getTransform" ref="a1517ef18a8405133b722b4ee892ebed6" args="(const std::string &amp;coordinateSystem) const =0" -->
virtual Imath::M44f&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIECore_1_1Renderer.html#a1517ef18a8405133b722b4ee892ebed6">getTransform</a> (const std::string &amp;coordinateSystem) const =0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the transform associated with the named coordinate system. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a84d0abdca984ba646884240bc8b0e87d"></a><!-- doxytag: member="IECore::Renderer::concatTransform" ref="a84d0abdca984ba646884240bc8b0e87d" args="(const Imath::M44f &amp;m)=0" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIECore_1_1Renderer.html#a84d0abdca984ba646884240bc8b0e87d">concatTransform</a> (const Imath::M44f &amp;m)=0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Concatenates the specified transform onto the current transform. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ada15151c1e97d3658ec1da05be9c90d3"></a><!-- doxytag: member="IECore::Renderer::coordinateSystem" ref="ada15151c1e97d3658ec1da05be9c90d3" args="(const std::string &amp;name)=0" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIECore_1_1Renderer.html#ada15151c1e97d3658ec1da05be9c90d3">coordinateSystem</a> (const std::string &amp;name)=0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a named coordinate system from the current transform. <br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Attributes</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp287234a1ff35a314b5b6bc4e5828e745"></a> Attributes are named items of data which control some per-object aspect of the render. Attributes may be set both before and after <a class="el" href="classIECore_1_1Renderer.html#ae525ed886ed90f3286c412d3c3ad1503">worldBegin()</a>, and are scoped between <a class="el" href="classIECore_1_1Renderer.html#aa0db292a4c2ac8e06358d824082c885f">attributeBegin()</a>, <a class="el" href="classIECore_1_1Renderer.html#a6469352678b05c8085fac0491a7c0d8f" title="Return to the attribute state saved by the last call to attributeBegin().">attributeEnd()</a> calls. </p>
<br/><br/></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIECore_1_1Renderer.html#aa0db292a4c2ac8e06358d824082c885f">attributeBegin</a> ()=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6469352678b05c8085fac0491a7c0d8f"></a><!-- doxytag: member="IECore::Renderer::attributeEnd" ref="a6469352678b05c8085fac0491a7c0d8f" args="()=0" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIECore_1_1Renderer.html#a6469352678b05c8085fac0491a7c0d8f">attributeEnd</a> ()=0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return to the attribute state saved by the last call to <a class="el" href="classIECore_1_1Renderer.html#aa0db292a4c2ac8e06358d824082c885f">attributeBegin()</a>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIECore_1_1Renderer.html#a96aeb058ccd90020b5344a085d8317d0">setAttribute</a> (const std::string &amp;name, ConstDataPtr value)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a07037c535a9175978113dd52c7640b0f"></a><!-- doxytag: member="IECore::Renderer::getAttribute" ref="a07037c535a9175978113dd52c7640b0f" args="(const std::string &amp;name) const =0" -->
virtual ConstDataPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIECore_1_1Renderer.html#a07037c535a9175978113dd52c7640b0f">getAttribute</a> (const std::string &amp;name) const =0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the value of the named attribute. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5f5a34ede04a128db9db2240b50e6bad"></a><!-- doxytag: member="IECore::Renderer::shader" ref="a5f5a34ede04a128db9db2240b50e6bad" args="(const std::string &amp;type, const std::string &amp;name, const CompoundDataMap &amp;parameters)=0" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIECore_1_1Renderer.html#a5f5a34ede04a128db9db2240b50e6bad">shader</a> (const std::string &amp;type, const std::string &amp;name, const <a class="el" href="namespaceIECore.html#ab8801f59558a8c67f526d7c9d730cdda">CompoundDataMap</a> &amp;parameters)=0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specifies a shader to be applied to subsequent primitives. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abfc27a9f52f4ae71a8d15e693541e1f6"></a><!-- doxytag: member="IECore::Renderer::light" ref="abfc27a9f52f4ae71a8d15e693541e1f6" args="(const std::string &amp;name, const std::string &amp;handle, const CompoundDataMap &amp;parameters)=0" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIECore_1_1Renderer.html#abfc27a9f52f4ae71a8d15e693541e1f6">light</a> (const std::string &amp;name, const std::string &amp;handle, const <a class="el" href="namespaceIECore.html#ab8801f59558a8c67f526d7c9d730cdda">CompoundDataMap</a> &amp;parameters)=0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specifies a light to apply to subsequent primitives. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a161c5c0c5ad4dd3ecf73e94f3d9fca50"></a><!-- doxytag: member="IECore::Renderer::illuminate" ref="a161c5c0c5ad4dd3ecf73e94f3d9fca50" args="(const std::string &amp;lightHandle, bool on)=0" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIECore_1_1Renderer.html#a161c5c0c5ad4dd3ecf73e94f3d9fca50">illuminate</a> (const std::string &amp;lightHandle, bool on)=0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Turns the specified light on or off for the current attribute state. <br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Motion blur</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp3b83ae40fbe28192f2992f72549a87e1"></a>///////////////////////////////////////////////////////////////////////// </p>
<br/><br/></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIECore_1_1Renderer.html#a1468320b6f166544a1a1193eb25365be">motionBegin</a> (const std::set&lt; float &gt; &amp;times)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIECore_1_1Renderer.html#aa195e2e8ec823abfa2ba9e08ed328149">motionEnd</a> ()=0</td></tr>
<tr><td colspan="2"><div class="groupHeader">Primitives</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp6f1b10c83f41962b7bc970aa1514f337"></a> Primitives specify actual visible objects to be rendered. Each primitive has a topology which is usually specified in a manner unique to that type, and a set of PrimitiveVariables which is specified in the same manner for all primitives - these specify data to vary over the surface of the primitive. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000049">Todo:</a></b></dt><dd>Better documentation for the calls below, particularly in relation to the rightHandedOrientation attribute. </dd></dl>
<br/><br/></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a06ef00615a53a48bfdfbe1e48669d836"></a><!-- doxytag: member="IECore::Renderer::points" ref="a06ef00615a53a48bfdfbe1e48669d836" args="(size_t numPoints, const PrimitiveVariableMap &amp;primVars)=0" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIECore_1_1Renderer.html#a06ef00615a53a48bfdfbe1e48669d836">points</a> (size_t numPoints, const <a class="el" href="namespaceIECore.html#a8831a05758aad0cc4f1968f74afdffca">PrimitiveVariableMap</a> &amp;primVars)=0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Renders a set of points. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIECore_1_1Renderer.html#a12bb1618d491f2a9f21a1ddb9f1c5f3a">disk</a> (float radius, float z, float thetaMax, const <a class="el" href="namespaceIECore.html#a8831a05758aad0cc4f1968f74afdffca">PrimitiveVariableMap</a> &amp;primVars)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adb6abe5690183873c0bcb38a92218f0b"></a><!-- doxytag: member="IECore::Renderer::curves" ref="adb6abe5690183873c0bcb38a92218f0b" args="(const CubicBasisf &amp;basis, bool periodic, ConstIntVectorDataPtr numVertices, const IECore::PrimitiveVariableMap &amp;primVars)=0" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIECore_1_1Renderer.html#adb6abe5690183873c0bcb38a92218f0b">curves</a> (const <a class="el" href="classIECore_1_1CubicBasis.html">CubicBasisf</a> &amp;basis, bool periodic, ConstIntVectorDataPtr numVertices, const <a class="el" href="namespaceIECore.html#a8831a05758aad0cc4f1968f74afdffca">IECore::PrimitiveVariableMap</a> &amp;primVars)=0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Renders a set of curves. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab6d5b5b38e65aaaafe14e911b154767b"></a><!-- doxytag: member="IECore::Renderer::text" ref="ab6d5b5b38e65aaaafe14e911b154767b" args="(const std::string &amp;font, const std::string &amp;text, float kerning=1.0f, const PrimitiveVariableMap &amp;primVars=PrimitiveVariableMap())=0" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIECore_1_1Renderer.html#ab6d5b5b38e65aaaafe14e911b154767b">text</a> (const std::string &amp;font, const std::string &amp;text, float kerning=1.0f, const PrimitiveVariableMap &amp;primVars=PrimitiveVariableMap())=0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Renders some text. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIECore_1_1Renderer.html#a94869f43c647947b0ca88c8b527c2a58">sphere</a> (float radius, float zMin, float zMax, float thetaMax, const <a class="el" href="namespaceIECore.html#a8831a05758aad0cc4f1968f74afdffca">PrimitiveVariableMap</a> &amp;primVars)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIECore_1_1Renderer.html#ab72852161207aa3efda6d5c9b692fdd3">image</a> (const Imath::Box2i &amp;dataWindow, const Imath::Box2i &amp;displayWindow, const <a class="el" href="namespaceIECore.html#a8831a05758aad0cc4f1968f74afdffca">PrimitiveVariableMap</a> &amp;primVars)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIECore_1_1Renderer.html#ac8d0e772ec325bec6f088e41ce7cb330">mesh</a> (ConstIntVectorDataPtr vertsPerFace, ConstIntVectorDataPtr vertIds, const std::string &amp;interpolation, const <a class="el" href="namespaceIECore.html#a8831a05758aad0cc4f1968f74afdffca">PrimitiveVariableMap</a> &amp;primVars)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa7d7d997c0991838cdc68194e604c91c"></a><!-- doxytag: member="IECore::Renderer::nurbs" ref="aa7d7d997c0991838cdc68194e604c91c" args="(int uOrder, ConstFloatVectorDataPtr uKnot, float uMin, float uMax, int vOrder, ConstFloatVectorDataPtr vKnot, float vMin, float vMax, const PrimitiveVariableMap &amp;primVars)=0" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIECore_1_1Renderer.html#aa7d7d997c0991838cdc68194e604c91c">nurbs</a> (int uOrder, ConstFloatVectorDataPtr uKnot, float uMin, float uMax, int vOrder, ConstFloatVectorDataPtr vKnot, float vMin, float vMax, const <a class="el" href="namespaceIECore.html#a8831a05758aad0cc4f1968f74afdffca">PrimitiveVariableMap</a> &amp;primVars)=0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Renders a nurbs surface. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a853477389d17b63cca1804cf98302558"></a><!-- doxytag: member="IECore::Renderer::patchMesh" ref="a853477389d17b63cca1804cf98302558" args="(const CubicBasisf &amp;uBasis, const CubicBasisf &amp;vBasis, int nu, bool uPeriodic, int nv, bool vPeriodic, const PrimitiveVariableMap &amp;primVars)=0" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIECore_1_1Renderer.html#a853477389d17b63cca1804cf98302558">patchMesh</a> (const <a class="el" href="classIECore_1_1CubicBasis.html">CubicBasisf</a> &amp;uBasis, const <a class="el" href="classIECore_1_1CubicBasis.html">CubicBasisf</a> &amp;vBasis, int nu, bool uPeriodic, int nv, bool vPeriodic, const <a class="el" href="namespaceIECore.html#a8831a05758aad0cc4f1968f74afdffca">PrimitiveVariableMap</a> &amp;primVars)=0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Render a patch mesh. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8019ffa4c48512bffea4b54b460dab9f"></a><!-- doxytag: member="IECore::Renderer::geometry" ref="a8019ffa4c48512bffea4b54b460dab9f" args="(const std::string &amp;type, const CompoundDataMap &amp;topology, const PrimitiveVariableMap &amp;primVars)=0" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIECore_1_1Renderer.html#a8019ffa4c48512bffea4b54b460dab9f">geometry</a> (const std::string &amp;type, const <a class="el" href="namespaceIECore.html#ab8801f59558a8c67f526d7c9d730cdda">CompoundDataMap</a> &amp;topology, const <a class="el" href="namespaceIECore.html#a8831a05758aad0cc4f1968f74afdffca">PrimitiveVariableMap</a> &amp;primVars)=0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generic call for specifying renderer specify geometry types. <br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Instancing</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrpddcb6ddc2c9a604e667096ede4a77493"></a> These methods provide a means of describing a portion of a scene once and reusing it many times. </p>
<br/><br/></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae705919ba22eee470a94ef9dae81cfe3"></a><!-- doxytag: member="IECore::Renderer::instanceBegin" ref="ae705919ba22eee470a94ef9dae81cfe3" args="(const std::string &amp;name, const CompoundDataMap &amp;parameters)=0" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIECore_1_1Renderer.html#ae705919ba22eee470a94ef9dae81cfe3">instanceBegin</a> (const std::string &amp;name, const <a class="el" href="namespaceIECore.html#ab8801f59558a8c67f526d7c9d730cdda">CompoundDataMap</a> &amp;parameters)=0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Starts the description of a portion of a scene to be instanced. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2c8b1fa07e07cfd0bab324ae08e3512c"></a><!-- doxytag: member="IECore::Renderer::instanceEnd" ref="a2c8b1fa07e07cfd0bab324ae08e3512c" args="()=0" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIECore_1_1Renderer.html#a2c8b1fa07e07cfd0bab324ae08e3512c">instanceEnd</a> ()=0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Ends the description of an instance. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIECore_1_1Renderer.html#a647895f399319f4cbb5540934f6a8405">instance</a> (const std::string &amp;name)=0</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>The <a class="el" href="classIECore_1_1Renderer.html">Renderer</a> class provides a means of describing scenes for rendering. Its interface is modelled closely on OpenGL/Renderman with an attribute and transform stack etc. <a class="el" href="classIECore_1_1Renderer.html">Renderer</a> implementations should flag errors and warnings using the <a class="el" href="classIECore_1_1MessageHandler.html">MessageHandler</a> class rather than by throwing Exceptions - it's often more useful to have an incomplete image for diagnosis of the problem than to have an <a class="el" href="classIECore_1_1Exception.html">Exception</a> thrown.</p>
<dl class="user"><dt><b>Naming conventions</b></dt><dd></dd></dl>
<p>Many of the calls in the <a class="el" href="classIECore_1_1Renderer.html">Renderer</a> interface associate a name with a piece of data. Both the <a class="el" href="classIECore_1_1Renderer.html#acd834661ea7c64c6987bfa660d08f650" title="Set an option. Must not be called after worldBegin().">setOption()</a> and <a class="el" href="classIECore_1_1Renderer.html#a96aeb058ccd90020b5344a085d8317d0">setAttribute()</a> calls take a name to specify what is being modified and a DataPtr to specify the new value. Many other calls accept either a CompoundDataMap or a PrimitiveVariableMap, both of which may contain many named pieces of <a class="el" href="classIECore_1_1Data.html">Data</a>.</p>
<p>A naming convention exists to specify that particular data is intended only for a particular <a class="el" href="classIECore_1_1Renderer.html">Renderer</a> implementation. This allows rendering to be customised for a particular implementation without causing other implementations to error due to unsupported features. The convention for each name is as follows :</p>
<ul>
<li><b>"name"</b><br/>
 Should be supported by all <a class="el" href="classIECore_1_1Renderer.html">Renderer</a> implementations. For instance, the "doubleSided" attribute should be supported by all Renderers. A warning message should be output if the name is not recognised and supported.</li>
</ul>
<ul>
<li><b>"prefix:name"</b><br/>
 Used to specify data intended only for a particular implementation. Implementations silently ignore all data destined for other implementations. For instance, the "gl:primitive:wireframe" attribute is used by the GL renderer implementation but silently ignored by other implementations.</li>
</ul>
<ul>
<li><b>"user:name"</b><br/>
 Used to specify data for the purposes of users. The renderer should store the value and make it available for query, but otherwise it should have no effect. This applies mostly to the attribute and option calls. </li>
</ul>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="aa0db292a4c2ac8e06358d824082c885f"></a><!-- doxytag: member="IECore::Renderer::attributeBegin" ref="aa0db292a4c2ac8e06358d824082c885f" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void IECore::Renderer::attributeBegin </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Push a new attribute state onto the attribute stack. This is identical to the current state, but subsequent calls to <a class="el" href="classIECore_1_1Renderer.html#a96aeb058ccd90020b5344a085d8317d0">setAttribute()</a> will be discarded by the matching <a class="el" href="classIECore_1_1Renderer.html#a6469352678b05c8085fac0491a7c0d8f" title="Return to the attribute state saved by the last call to attributeBegin().">attributeEnd()</a>. </p>

<p>Implemented in <a class="el" href="classIECore_1_1CapturingRenderer.html#a4f733ce84757eb16af545c84b1d7ef04">IECore::CapturingRenderer</a>, <a class="el" href="classIECoreRI_1_1Renderer.html#ae24b2ca7b947fa8c700d2c32800a95d7">IECoreRI::Renderer</a>, and <a class="el" href="classIECoreGL_1_1Renderer.html#a1702c699dc0e41341f252ab7f8cacf52">IECoreGL::Renderer</a>.</p>

</div>
</div>
<a class="anchor" id="a3faf858c0be8b8d54950c25bc5c15429"></a><!-- doxytag: member="IECore::Renderer::camera" ref="a3faf858c0be8b8d54950c25bc5c15429" args="(const std::string &amp;name, const CompoundDataMap &amp;parameters)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void IECore::Renderer::camera </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceIECore.html#ab8801f59558a8c67f526d7c9d730cdda">CompoundDataMap</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>parameters</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Creates a named camera at the position defined by the current transform. The camera looks down negative Z, with screen space left to right being positive X and screen space top to bottom being positive Y. The last camera specified before <a class="el" href="classIECore_1_1Renderer.html#ae525ed886ed90f3286c412d3c3ad1503">worldBegin()</a> is considered to be the camera for rendering through - other cameras may be used in implementation specific ways by <a class="el" href="classIECore_1_1Renderer.html">Renderer</a> subclasses.</p>
<dl class="user"><dt><b>Standard Parameters</b></dt><dd><br/>
 The following standard parameters should be supported by all implementations wherever possible - they are largely based on the RenderMan specification :</dd></dl>
<ul>
<li><b>"resolution" V2iData</b><br/>
 The resolution of any output images. Should default to 640x480 if not specified.</li>
</ul>
<ul>
<li><b>"screenWindow" Box2fData</b><br/>
 The region in screen space which is mapped to the output resolution. If unspecified then this should default to -1,1 in the smallest image dimension and the other dimension should be sized appropriately to preserve pixel aspect ratio.</li>
</ul>
<ul>
<li><b>"cropWindow" Box2fData</b><br/>
 The region in raster space which should actually be rendered - this allows just a section of the full resolution to be rendered. Note that raster space runs from 0,0 at the top left to 1,1 at the bottom right. Defaults to 0,0 1,1 if not specified.</li>
</ul>
<ul>
<li><b>"projection" StringData</b><br/>
 The projection that determines how camera coordinates are converted to screen space coordinates. Implementations should support "perspective" and "orthographic", with orthographic being the default if not specified.</li>
</ul>
<ul>
<li><b>"projection:fov" FloatData</b><br/>
 In the case of the "projection" parameter specifying a perspective projection, this specifies the field of view (in degrees) which is visible between -1 and 1 in screen space. Defaults to 90 degrees if unspecified.</li>
</ul>
<ul>
<li><b>"clippingPlanes" V2fData</b><br/>
 The near and far clipping planes. Defaults to 0.01, 100000 if unspecified.</li>
</ul>
<ul>
<li><b>"shutter" V2fData</b><br/>
 The time interval for which the shutter is open - this is used in conjunction with the times passed to <a class="el" href="classIECore_1_1Renderer.html#a1468320b6f166544a1a1193eb25365be">motionBegin()</a> to specify motion blur. Defaults to 0,0 if unspecified. </li>
</ul>

<p>Implemented in <a class="el" href="classIECore_1_1CapturingRenderer.html#acb17ef29ed95aabf3d4255ad3a204a9c">IECore::CapturingRenderer</a>, <a class="el" href="classIECoreRI_1_1Renderer.html#a31d49ca667775a476729831d775a50e6">IECoreRI::Renderer</a>, and <a class="el" href="classIECoreGL_1_1Renderer.html#a7813f096d75df0e6341f2129c7706b74">IECoreGL::Renderer</a>.</p>

</div>
</div>
<a class="anchor" id="af6002d21ab8243698183b8f4b7db1ae8"></a><!-- doxytag: member="IECore::Renderer::command" ref="af6002d21ab8243698183b8f4b7db1ae8" args="(const std::string &amp;name, const CompoundDataMap &amp;parameters)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual DataPtr IECore::Renderer::command </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceIECore.html#ab8801f59558a8c67f526d7c9d730cdda">CompoundDataMap</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>parameters</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Generic call for executing arbitrary renderer commands. This is intended to allow derived classes to support calls such as RiMakeTexture via calls of the form renderer-&gt;command( "ri:makeTexture", ... ). </p>

<p>Implemented in <a class="el" href="classIECore_1_1CapturingRenderer.html#ac0128793329d9de098d075c55075dfff">IECore::CapturingRenderer</a>, <a class="el" href="classIECoreRI_1_1Renderer.html#a179b54fef6eb51e0135bbb51e2f66fd7">IECoreRI::Renderer</a>, and <a class="el" href="classIECoreGL_1_1Renderer.html#a67587c2ea783f2a0029341b2ce05cfe6">IECoreGL::Renderer</a>.</p>

</div>
</div>
<a class="anchor" id="a12bb1618d491f2a9f21a1ddb9f1c5f3a"></a><!-- doxytag: member="IECore::Renderer::disk" ref="a12bb1618d491f2a9f21a1ddb9f1c5f3a" args="(float radius, float z, float thetaMax, const PrimitiveVariableMap &amp;primVars)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void IECore::Renderer::disk </td>
          <td>(</td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>thetaMax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceIECore.html#a8831a05758aad0cc4f1968f74afdffca">PrimitiveVariableMap</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>primVars</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Renders a disk of the specified radius on the xy plane, at the specified z value. If the "rightHandedOrientation" attribute is true then the normal faces down positive z, otherwise it faces down negative z. </p>

<p>Implemented in <a class="el" href="classIECore_1_1CapturingRenderer.html#af59cfcd3be7cbcd7c071d1b530b876aa">IECore::CapturingRenderer</a>, <a class="el" href="classIECoreRI_1_1Renderer.html#ad88749a4c1b5560256a4918cd11b35f4">IECoreRI::Renderer</a>, and <a class="el" href="classIECoreGL_1_1Renderer.html#a1f96f4eba40e94158ba76fe0392398ba">IECoreGL::Renderer</a>.</p>

</div>
</div>
<a class="anchor" id="a6701d3d585217ccdac915ac300b81130"></a><!-- doxytag: member="IECore::Renderer::display" ref="a6701d3d585217ccdac915ac300b81130" args="(const std::string &amp;name, const std::string &amp;type, const std::string &amp;data, const CompoundDataMap &amp;parameters)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void IECore::Renderer::display </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceIECore.html#ab8801f59558a8c67f526d7c9d730cdda">CompoundDataMap</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>parameters</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Specifies an image to be output from the renderer. In the case of file outputs name specified the filename. type specifies the type of output to create and data specifies the data to be output, for instance "rgba". parameters provides an implementation specific set of parameters to control other aspects of the image created. It is only valid to call this before worldBegin. </p>

<p>Implemented in <a class="el" href="classIECore_1_1CapturingRenderer.html#adc4039877e308f726b261a24e1f5ee03">IECore::CapturingRenderer</a>, <a class="el" href="classIECoreRI_1_1Renderer.html#a530e8fa4e602eca1a5b1b6bd7bd20a47">IECoreRI::Renderer</a>, and <a class="el" href="classIECoreGL_1_1Renderer.html#a7092ff8679776ee1218c451ac0b003c2">IECoreGL::Renderer</a>.</p>

</div>
</div>
<a class="anchor" id="ab72852161207aa3efda6d5c9b692fdd3"></a><!-- doxytag: member="IECore::Renderer::image" ref="ab72852161207aa3efda6d5c9b692fdd3" args="(const Imath::Box2i &amp;dataWindow, const Imath::Box2i &amp;displayWindow, const PrimitiveVariableMap &amp;primVars)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void IECore::Renderer::image </td>
          <td>(</td>
          <td class="paramtype">const Imath::Box2i &amp;&nbsp;</td>
          <td class="paramname"> <em>dataWindow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Imath::Box2i &amp;&nbsp;</td>
          <td class="paramname"> <em>displayWindow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceIECore.html#a8831a05758aad0cc4f1968f74afdffca">PrimitiveVariableMap</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>primVars</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Renders an image. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000051">Todo:</a></b></dt><dd>Clarify the intended use of dataWindow and displayWindow. </dd></dl>

<p>Implemented in <a class="el" href="classIECore_1_1CapturingRenderer.html#a600f34ac498522870409de5df22999bc">IECore::CapturingRenderer</a>, <a class="el" href="classIECoreRI_1_1Renderer.html#a0bdc8db0d493604b30eb22bd16900c62">IECoreRI::Renderer</a>, and <a class="el" href="classIECoreGL_1_1Renderer.html#a2f72abed36e005957ace5b0134bf407b">IECoreGL::Renderer</a>.</p>

</div>
</div>
<a class="anchor" id="a647895f399319f4cbb5540934f6a8405"></a><!-- doxytag: member="IECore::Renderer::instance" ref="a647895f399319f4cbb5540934f6a8405" args="(const std::string &amp;name)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void IECore::Renderer::instance </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Instantiates a previously described instance at the current transform position, and using the current attribute state. </p>

<p>Implemented in <a class="el" href="classIECore_1_1CapturingRenderer.html#a6e9c25b567f0e8df2f07ae1271eac86a">IECore::CapturingRenderer</a>, <a class="el" href="classIECoreRI_1_1Renderer.html#a8b4c9b07d05b52f9adbd1b27a3693977">IECoreRI::Renderer</a>, and <a class="el" href="classIECoreGL_1_1Renderer.html#a9ab720df63b3dc34284f73af94c23002">IECoreGL::Renderer</a>.</p>

</div>
</div>
<a class="anchor" id="ac8d0e772ec325bec6f088e41ce7cb330"></a><!-- doxytag: member="IECore::Renderer::mesh" ref="ac8d0e772ec325bec6f088e41ce7cb330" args="(ConstIntVectorDataPtr vertsPerFace, ConstIntVectorDataPtr vertIds, const std::string &amp;interpolation, const PrimitiveVariableMap &amp;primVars)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void IECore::Renderer::mesh </td>
          <td>(</td>
          <td class="paramtype">ConstIntVectorDataPtr&nbsp;</td>
          <td class="paramname"> <em>vertsPerFace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ConstIntVectorDataPtr&nbsp;</td>
          <td class="paramname"> <em>vertIds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>interpolation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceIECore.html#a8831a05758aad0cc4f1968f74afdffca">PrimitiveVariableMap</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>primVars</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Renders a mesh. The geometric normal of a face will be facing camera if the winding order of its vertices is anticlockwise from the point of view of the camera and the "rightHandedOrientation" attribute is true. If the "rightHandedOrientation" attribute is false then faces whose vertices wind /clockwise/ with respect to the camera are considered forward facing instead. </p>

<p>Implemented in <a class="el" href="classIECore_1_1CapturingRenderer.html#a4f9d72fe5f5e48ce7b7e9c3c85f2d4b3">IECore::CapturingRenderer</a>.</p>

</div>
</div>
<a class="anchor" id="a1468320b6f166544a1a1193eb25365be"></a><!-- doxytag: member="IECore::Renderer::motionBegin" ref="a1468320b6f166544a1a1193eb25365be" args="(const std::set&lt; float &gt; &amp;times)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void IECore::Renderer::motionBegin </td>
          <td>(</td>
          <td class="paramtype">const std::set&lt; float &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>times</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Starts a new motion block. You should then make times.size() calls to one of the primitive or transform functions to specify the motion for the block. </p>

<p>Implemented in <a class="el" href="classIECore_1_1CapturingRenderer.html#af73cd857a9f6b805547c03694b99824d">IECore::CapturingRenderer</a>, <a class="el" href="classIECoreRI_1_1Renderer.html#ad7ec0233080519bc74418fcb799c8a8a">IECoreRI::Renderer</a>, and <a class="el" href="classIECoreGL_1_1Renderer.html#aa7b461b99a59a7802e90584aa15723cd">IECoreGL::Renderer</a>.</p>

</div>
</div>
<a class="anchor" id="aa195e2e8ec823abfa2ba9e08ed328149"></a><!-- doxytag: member="IECore::Renderer::motionEnd" ref="aa195e2e8ec823abfa2ba9e08ed328149" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void IECore::Renderer::motionEnd </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Ends a motion block. Should be called when times.size() calls to an appropriate primitive or transform function have been made following a <a class="el" href="classIECore_1_1Renderer.html#a1468320b6f166544a1a1193eb25365be">motionBegin()</a> call. </p>

<p>Implemented in <a class="el" href="classIECore_1_1CapturingRenderer.html#a1d9d5933f1dcdc16bc1d3a00a8e522d3">IECore::CapturingRenderer</a>, <a class="el" href="classIECoreRI_1_1Renderer.html#ab5b2ce1ba1176d98f1558169811d3dcf">IECoreRI::Renderer</a>, and <a class="el" href="classIECoreGL_1_1Renderer.html#a87b230e64de868cde14245016251f3c9">IECoreGL::Renderer</a>.</p>

</div>
</div>
<a class="anchor" id="a96aeb058ccd90020b5344a085d8317d0"></a><!-- doxytag: member="IECore::Renderer::setAttribute" ref="a96aeb058ccd90020b5344a085d8317d0" args="(const std::string &amp;name, ConstDataPtr value)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void IECore::Renderer::setAttribute </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ConstDataPtr&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets the named attribute to the specified value.</p>
<dl class="user"><dt><b>Standard Attributes</b></dt><dd><br/>
 The following standard attributes should be supported by all implementations wherever possible :</dd></dl>
<ul>
<li><b>"color" Color3fData</b><br/>
 The color of primitives. Defaults to 1, 1, 1 if not specified.</li>
</ul>
<ul>
<li><b>"opacity" Color3fData</b><br/>
 The opacity of primitives. Defaults to 1, 1, 1 if not specified.</li>
</ul>
<ul>
<li><b>"doubleSided" BoolData</b><br/>
 When true both sides of a primitive are rendered, when false only one side is. Defaults to true.</li>
</ul>
<ul>
<li><b>"rightHandedOrientation" BoolData</b><br/>
 Controls which side of a primitive is forward facing. This attribute starts with a value of true, because the camera is specified in a right handed coordinate system - a value of false specifies that the current orientation is left handed. The renderer will automatically toggle the value whenever a transformation flips the sense of the current object space coordinate system (this happens when a transform has a negative determinant - typically a negative scaling in some axis). You can change the interpretation of "forward facing" by flipping the attribute value at any time - see the documentation for the various primitives below for how orientation affects the way their front face is defined.</li>
</ul>
<ul>
<li><b>"name" StringData "unnamed"</b></li>
<li><b> </b> A descriptive name for the object.</li>
</ul>
<ul>
<li><b>"user:*"</b><br/>
 Should be stored for later query, but have no other effect upon the rendering process. </li>
</ul>

<p>Implemented in <a class="el" href="classIECore_1_1CapturingRenderer.html#a5f3acc72f2f9a0881e4a3a20c54f4dbb">IECore::CapturingRenderer</a>.</p>

</div>
</div>
<a class="anchor" id="ae40039c9e135edc5250f9ab709af56d5"></a><!-- doxytag: member="IECore::Renderer::setTransform" ref="ae40039c9e135edc5250f9ab709af56d5" args="(const std::string &amp;coordinateSystem)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void IECore::Renderer::setTransform </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>coordinateSystem</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets the current transform to a coordinate system previously created with a call to <a class="el" href="classIECore_1_1Renderer.html#ada15151c1e97d3658ec1da05be9c90d3" title="Creates a named coordinate system from the current transform.">coordinateSystem()</a>. </p>

<p>Implemented in <a class="el" href="classIECore_1_1CapturingRenderer.html#a8d6217cf3ee7527980054649473c80ac">IECore::CapturingRenderer</a>, <a class="el" href="classIECoreRI_1_1Renderer.html#acc16f4c576e3a2a2e2c4acc4dc20722f">IECoreRI::Renderer</a>, and <a class="el" href="classIECoreGL_1_1Renderer.html#a8c3962236748aa6efa8e0f0e9017267a">IECoreGL::Renderer</a>.</p>

</div>
</div>
<a class="anchor" id="a94869f43c647947b0ca88c8b527c2a58"></a><!-- doxytag: member="IECore::Renderer::sphere" ref="a94869f43c647947b0ca88c8b527c2a58" args="(float radius, float zMin, float zMax, float thetaMax, const PrimitiveVariableMap &amp;primVars)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void IECore::Renderer::sphere </td>
          <td>(</td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>zMin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>zMax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>thetaMax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceIECore.html#a8831a05758aad0cc4f1968f74afdffca">PrimitiveVariableMap</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>primVars</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Renders a sphere of the specified radius. zMin and zMax are measured as a proportion of the radius - so no matter what the radius, the default values will always give a full sphere. If the "rightHandedOrientation" attribute is true then the normals point outwards, otherwise they point inwards. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000050">Todo:</a></b></dt><dd>Give this the default values it talks about. </dd></dl>

<p>Implemented in <a class="el" href="classIECore_1_1CapturingRenderer.html#a3bed05d56a16c1864ffd399b707d7acb">IECore::CapturingRenderer</a>, <a class="el" href="classIECoreRI_1_1Renderer.html#a0e7ede6557b575c14031eb2d851186a7">IECoreRI::Renderer</a>, and <a class="el" href="classIECoreGL_1_1Renderer.html#ab5cd828707163f7600e78925e973a5fe">IECoreGL::Renderer</a>.</p>

</div>
</div>
<a class="anchor" id="a8de999de675f13ad6b0c75aef9507508"></a><!-- doxytag: member="IECore::Renderer::transformBegin" ref="a8de999de675f13ad6b0c75aef9507508" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void IECore::Renderer::transformBegin </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Push a new transform state identical to the current one. Modifications can then be made locally before calling <a class="el" href="classIECore_1_1Renderer.html#a720c43eccd8e823aa52e4e810bc2b479" title="Returns to the transform state saved by the last transformBegin() call.">transformEnd()</a> to return to the previous transform state. </p>

<p>Implemented in <a class="el" href="classIECore_1_1CapturingRenderer.html#a3b975fcfc158918c8484d7d1ae159ce0">IECore::CapturingRenderer</a>, <a class="el" href="classIECoreRI_1_1Renderer.html#a25c8bef90677f2f838a3520c30a18a0f">IECoreRI::Renderer</a>, and <a class="el" href="classIECoreGL_1_1Renderer.html#a366d44018791c93e3049f87b94d7c99a">IECoreGL::Renderer</a>.</p>

</div>
</div>
<a class="anchor" id="ae525ed886ed90f3286c412d3c3ad1503"></a><!-- doxytag: member="IECore::Renderer::worldBegin" ref="ae525ed886ed90f3286c412d3c3ad1503" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void IECore::Renderer::worldBegin </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Starts the world block and resets the current transform to the identity. </p>

<p>Implemented in <a class="el" href="classIECore_1_1CapturingRenderer.html#a0bbed7d79fbd727483779a1b4f88f657">IECore::CapturingRenderer</a>, <a class="el" href="classIECoreRI_1_1Renderer.html#aef99c72b40799828ff461e7ba81bd53d">IECoreRI::Renderer</a>, and <a class="el" href="classIECoreGL_1_1Renderer.html#a34105398ff19bb8267e585b47abfe1f1">IECoreGL::Renderer</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/IECore/<a class="el" href="Renderer_8h_source.html">Renderer.h</a></li>
</ul>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&nbsp;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&nbsp;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&nbsp;</span>Friends</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr size="1"/><address style="text-align: right;"><small>Generated on 5 Jan 2012 for Cortex by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
