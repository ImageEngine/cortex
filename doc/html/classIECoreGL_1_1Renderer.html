<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Cortex: IECoreGL::Renderer Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.6.1 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<script type="text/javascript">
<!--
function changeDisplayState (e){
  var num=this.id.replace(/[^[0-9]/g,'');
  var button=this.firstChild;
  var sectionDiv=document.getElementById('dynsection'+num);
  if (sectionDiv.style.display=='none'||sectionDiv.style.display==''){
    sectionDiv.style.display='block';
    button.src='open.gif';
  }else{
    sectionDiv.style.display='none';
    button.src='closed.gif';
  }
}
function initDynSections(){
  var divs=document.getElementsByTagName('div');
  var sectionCounter=1;
  for(var i=0;i<divs.length-1;i++){
    if(divs[i].className=='dynheader'&&divs[i+1].className=='dynsection'){
      var header=divs[i];
      var section=divs[i+1];
      var button=header.firstChild;
      if (button!='IMG'){
        divs[i].insertBefore(document.createTextNode(' '),divs[i].firstChild);
        button=document.createElement('img');
        divs[i].insertBefore(button,divs[i].firstChild);
      }
      header.style.cursor='pointer';
      header.onclick=changeDisplayState;
      header.id='dynheader'+sectionCounter;
      button.src='closed.gif';
      section.id='dynsection'+sectionCounter;
      section.style.display='none';
      section.style.marginLeft='14px';
      sectionCounter++;
    }
  }
}
window.onload = initDynSections;
-->
</script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <img id="MSearchSelect" src="search/search.png"
             onmouseover="return searchBox.OnSearchSelectShow()"
             onmouseout="return searchBox.OnSearchSelectHide()"
             alt=""/>
        <input type="text" id="MSearchField" value="Search" accesskey="S"
             onfocus="searchBox.OnSearchFieldFocus(true)" 
             onblur="searchBox.OnSearchFieldFocus(false)" 
             onkeyup="searchBox.OnSearchFieldChange(event)"/>
        <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
        </div>
      </li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="namespaceIECoreGL.html">IECoreGL</a>::<a class="el" href="classIECoreGL_1_1Renderer.html">Renderer</a>
  </div>
</div>
<div class="contents">
<h1>IECoreGL::Renderer Class Reference<br/>
<small>
[<a class="el" href="group__renderingGroup.html">Rendering</a>]</small>
</h1><!-- doxytag: class="IECoreGL::Renderer" --><!-- doxytag: inherits="IECore::Renderer" -->
<p><code>#include &lt;<a class="el" href="L_2Renderer_8h_source.html">Renderer.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for IECoreGL::Renderer:</div>
<div class="dynsection">
 <div class="center">
  <img src="classIECoreGL_1_1Renderer.gif" usemap="#IECoreGL::Renderer_map" alt=""/>
  <map id="IECoreGL::Renderer_map" name="IECoreGL::Renderer_map">
<area href="classIECore_1_1Renderer.html" alt="IECore::Renderer" shape="rect" coords="0,112,140,136"/>
<area href="classIECore_1_1RunTimeTyped.html" alt="IECore::RunTimeTyped" shape="rect" coords="0,56,140,80"/>
<area href="classIECore_1_1RefCounted.html" alt="IECore::RefCounted" shape="rect" coords="0,0,140,24"/>
</map>
 </div>
</div>

<p><a href="classIECoreGL_1_1Renderer-members.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a23680dfb3a74d0c59629a88af1ee6e38"></a><!-- doxytag: member="IECoreGL::Renderer::IE_CORE_DECLARERUNTIMETYPEDEXTENSION" ref="a23680dfb3a74d0c59629a88af1ee6e38" args="(IECoreGL::Renderer, RendererTypeId, IECore::Renderer)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><b>IE_CORE_DECLARERUNTIMETYPEDEXTENSION</b> (<a class="el" href="classIECoreGL_1_1Renderer.html">IECoreGL::Renderer</a>, RendererTypeId, <a class="el" href="classIECore_1_1Renderer.html">IECore::Renderer</a>)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIECoreGL_1_1Renderer.html#a3615f6f7c8edd15173a8c51b142cd32d">setOption</a> (const std::string &amp;name, IECore::ConstDataPtr value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad4dfe3583b3fd1377f4fd3a56133222d"></a><!-- doxytag: member="IECoreGL::Renderer::getOption" ref="ad4dfe3583b3fd1377f4fd3a56133222d" args="(const std::string &amp;name) const " -->
virtual IECore::ConstDataPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIECoreGL_1_1Renderer.html#ad4dfe3583b3fd1377f4fd3a56133222d">getOption</a> (const std::string &amp;name) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the value of a previously set option. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIECoreGL_1_1Renderer.html#a7813f096d75df0e6341f2129c7706b74">camera</a> (const std::string &amp;name, const <a class="el" href="namespaceIECore.html#ab8801f59558a8c67f526d7c9d730cdda">IECore::CompoundDataMap</a> &amp;parameters)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIECoreGL_1_1Renderer.html#a7092ff8679776ee1218c451ac0b003c2">display</a> (const std::string &amp;name, const std::string &amp;type, const std::string &amp;data, const <a class="el" href="namespaceIECore.html#ab8801f59558a8c67f526d7c9d730cdda">IECore::CompoundDataMap</a> &amp;parameters)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIECoreGL_1_1Renderer.html#a34105398ff19bb8267e585b47abfe1f1">worldBegin</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a81b7a428f1d7d9feecbd208f1e6eb93a"></a><!-- doxytag: member="IECoreGL::Renderer::worldEnd" ref="a81b7a428f1d7d9feecbd208f1e6eb93a" args="()" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIECoreGL_1_1Renderer.html#a81b7a428f1d7d9feecbd208f1e6eb93a">worldEnd</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Finishes the world block. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ScenePtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIECoreGL_1_1Renderer.html#a472903d90b68dbffc1cc0e7e6df56cc0">scene</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIECoreGL_1_1Renderer.html#a366d44018791c93e3049f87b94d7c99a">transformBegin</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa8344717cb99ff7cf8833c541e644684"></a><!-- doxytag: member="IECoreGL::Renderer::transformEnd" ref="aa8344717cb99ff7cf8833c541e644684" args="()" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIECoreGL_1_1Renderer.html#aa8344717cb99ff7cf8833c541e644684">transformEnd</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns to the transform state saved by the last <a class="el" href="classIECoreGL_1_1Renderer.html#a366d44018791c93e3049f87b94d7c99a">transformBegin()</a> call. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab8d1bb3f5dc8794b53a26fe47469ff2b"></a><!-- doxytag: member="IECoreGL::Renderer::setTransform" ref="ab8d1bb3f5dc8794b53a26fe47469ff2b" args="(const Imath::M44f &amp;m)" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIECoreGL_1_1Renderer.html#ab8d1bb3f5dc8794b53a26fe47469ff2b">setTransform</a> (const Imath::M44f &amp;m)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the current transform. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIECoreGL_1_1Renderer.html#a8c3962236748aa6efa8e0f0e9017267a">setTransform</a> (const std::string &amp;coordinateSystem)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2d9a27526b0d686611686a870d9a007c"></a><!-- doxytag: member="IECoreGL::Renderer::getTransform" ref="a2d9a27526b0d686611686a870d9a007c" args="() const " -->
virtual Imath::M44f&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIECoreGL_1_1Renderer.html#a2d9a27526b0d686611686a870d9a007c">getTransform</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the current transform. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8b9603fd18b1739dcb03fd735a07b330"></a><!-- doxytag: member="IECoreGL::Renderer::getTransform" ref="a8b9603fd18b1739dcb03fd735a07b330" args="(const std::string &amp;coordinateSystem) const " -->
virtual Imath::M44f&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIECoreGL_1_1Renderer.html#a8b9603fd18b1739dcb03fd735a07b330">getTransform</a> (const std::string &amp;coordinateSystem) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the transform associated with the named coordinate system. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af6d647ef064d75962f78b8c9f3ac5b1b"></a><!-- doxytag: member="IECoreGL::Renderer::concatTransform" ref="af6d647ef064d75962f78b8c9f3ac5b1b" args="(const Imath::M44f &amp;m)" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIECoreGL_1_1Renderer.html#af6d647ef064d75962f78b8c9f3ac5b1b">concatTransform</a> (const Imath::M44f &amp;m)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Concatenates the specified transform onto the current transform. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a86c5d85db533319b0df9c2a642ce8951"></a><!-- doxytag: member="IECoreGL::Renderer::coordinateSystem" ref="a86c5d85db533319b0df9c2a642ce8951" args="(const std::string &amp;name)" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIECoreGL_1_1Renderer.html#a86c5d85db533319b0df9c2a642ce8951">coordinateSystem</a> (const std::string &amp;name)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a named coordinate system from the current transform. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIECoreGL_1_1Renderer.html#a1702c699dc0e41341f252ab7f8cacf52">attributeBegin</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad4ab5f30408dadb8b3e3b011d33ea295"></a><!-- doxytag: member="IECoreGL::Renderer::attributeEnd" ref="ad4ab5f30408dadb8b3e3b011d33ea295" args="()" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIECoreGL_1_1Renderer.html#ad4ab5f30408dadb8b3e3b011d33ea295">attributeEnd</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return to the attribute state saved by the last call to <a class="el" href="classIECoreGL_1_1Renderer.html#a1702c699dc0e41341f252ab7f8cacf52">attributeBegin()</a>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIECoreGL_1_1Renderer.html#a9b625028a444229dd7e9785b3b6ffd50">setAttribute</a> (const std::string &amp;name, IECore::ConstDataPtr value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4f9dd909e3ba8123a48cadd4e0219911"></a><!-- doxytag: member="IECoreGL::Renderer::getAttribute" ref="a4f9dd909e3ba8123a48cadd4e0219911" args="(const std::string &amp;name) const " -->
virtual IECore::ConstDataPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIECoreGL_1_1Renderer.html#a4f9dd909e3ba8123a48cadd4e0219911">getAttribute</a> (const std::string &amp;name) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the value of the named attribute. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIECoreGL_1_1Renderer.html#ac6134c40f82af161fcb95ec2a8a68068">shader</a> (const std::string &amp;type, const std::string &amp;name, const <a class="el" href="namespaceIECore.html#ab8801f59558a8c67f526d7c9d730cdda">IECore::CompoundDataMap</a> &amp;parameters)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afd092850db1f1f1747414f9d5b4ca4a6"></a><!-- doxytag: member="IECoreGL::Renderer::light" ref="afd092850db1f1f1747414f9d5b4ca4a6" args="(const std::string &amp;name, const std::string &amp;handle, const IECore::CompoundDataMap &amp;parameters)" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIECoreGL_1_1Renderer.html#afd092850db1f1f1747414f9d5b4ca4a6">light</a> (const std::string &amp;name, const std::string &amp;handle, const <a class="el" href="namespaceIECore.html#ab8801f59558a8c67f526d7c9d730cdda">IECore::CompoundDataMap</a> &amp;parameters)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specifies a light to apply to subsequent primitives. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afbb11ad3ac33e311fe7a86ccff14598b"></a><!-- doxytag: member="IECoreGL::Renderer::illuminate" ref="afbb11ad3ac33e311fe7a86ccff14598b" args="(const std::string &amp;lightHandle, bool on)" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIECoreGL_1_1Renderer.html#afbb11ad3ac33e311fe7a86ccff14598b">illuminate</a> (const std::string &amp;lightHandle, bool on)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Turns the specified light on or off for the current attribute state. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIECoreGL_1_1Renderer.html#aa7b461b99a59a7802e90584aa15723cd">motionBegin</a> (const std::set&lt; float &gt; &amp;times)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIECoreGL_1_1Renderer.html#a87b230e64de868cde14245016251f3c9">motionEnd</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIECoreGL_1_1Renderer.html#a73a9c38b0646edfd9b4124851c28c122">points</a> (size_t numPoints, const <a class="el" href="namespaceIECore.html#a8831a05758aad0cc4f1968f74afdffca">IECore::PrimitiveVariableMap</a> &amp;primVars)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIECoreGL_1_1Renderer.html#a1f96f4eba40e94158ba76fe0392398ba">disk</a> (float radius, float z, float thetaMax, const <a class="el" href="namespaceIECore.html#a8831a05758aad0cc4f1968f74afdffca">IECore::PrimitiveVariableMap</a> &amp;primVars)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIECoreGL_1_1Renderer.html#a2921243530c8ae0ba27508064b0969b6">curves</a> (const <a class="el" href="classIECore_1_1CubicBasis.html">IECore::CubicBasisf</a> &amp;basis, bool periodic, IECore::ConstIntVectorDataPtr numVertices, const <a class="el" href="namespaceIECore.html#a8831a05758aad0cc4f1968f74afdffca">IECore::PrimitiveVariableMap</a> &amp;primVars)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9b1340575f565f6b6c07ca1b3c82fa0d"></a><!-- doxytag: member="IECoreGL::Renderer::text" ref="a9b1340575f565f6b6c07ca1b3c82fa0d" args="(const std::string &amp;font, const std::string &amp;text, float kerning=1.0f, const IECore::PrimitiveVariableMap &amp;primVars=IECore::PrimitiveVariableMap())" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIECoreGL_1_1Renderer.html#a9b1340575f565f6b6c07ca1b3c82fa0d">text</a> (const std::string &amp;font, const std::string &amp;text, float kerning=1.0f, const IECore::PrimitiveVariableMap &amp;primVars=IECore::PrimitiveVariableMap())</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Renders some text. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIECoreGL_1_1Renderer.html#ab5cd828707163f7600e78925e973a5fe">sphere</a> (float radius, float zMin, float zMax, float thetaMax, const <a class="el" href="namespaceIECore.html#a8831a05758aad0cc4f1968f74afdffca">IECore::PrimitiveVariableMap</a> &amp;primVars)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIECoreGL_1_1Renderer.html#a2f72abed36e005957ace5b0134bf407b">image</a> (const Imath::Box2i &amp;dataWindow, const Imath::Box2i &amp;displayWindow, const <a class="el" href="namespaceIECore.html#a8831a05758aad0cc4f1968f74afdffca">IECore::PrimitiveVariableMap</a> &amp;primVars)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIECoreGL_1_1Renderer.html#ac400555b5fa076f374b9ce54b48817f0">mesh</a> (IECore::ConstIntVectorDataPtr vertsPerFace, IECore::ConstIntVectorDataPtr vertIds, const std::string &amp;interpolation, const <a class="el" href="namespaceIECore.html#a8831a05758aad0cc4f1968f74afdffca">IECore::PrimitiveVariableMap</a> &amp;primVars)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac3f520bb7e54c20ddfa5ea0f096e866e"></a><!-- doxytag: member="IECoreGL::Renderer::nurbs" ref="ac3f520bb7e54c20ddfa5ea0f096e866e" args="(int uOrder, IECore::ConstFloatVectorDataPtr uKnot, float uMin, float uMax, int vOrder, IECore::ConstFloatVectorDataPtr vKnot, float vMin, float vMax, const IECore::PrimitiveVariableMap &amp;primVars)" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>nurbs</b> (int uOrder, IECore::ConstFloatVectorDataPtr uKnot, float uMin, float uMax, int vOrder, IECore::ConstFloatVectorDataPtr vKnot, float vMin, float vMax, const <a class="el" href="namespaceIECore.html#a8831a05758aad0cc4f1968f74afdffca">IECore::PrimitiveVariableMap</a> &amp;primVars)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a184a166e2917b530bfc253b3fb3a9f78"></a><!-- doxytag: member="IECoreGL::Renderer::patchMesh" ref="a184a166e2917b530bfc253b3fb3a9f78" args="(const IECore::CubicBasisf &amp;uBasis, const IECore::CubicBasisf &amp;vBasis, int nu, bool uPeriodic, int nv, bool vPeriodic, const IECore::PrimitiveVariableMap &amp;primVars)" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIECoreGL_1_1Renderer.html#a184a166e2917b530bfc253b3fb3a9f78">patchMesh</a> (const <a class="el" href="classIECore_1_1CubicBasis.html">IECore::CubicBasisf</a> &amp;uBasis, const <a class="el" href="classIECore_1_1CubicBasis.html">IECore::CubicBasisf</a> &amp;vBasis, int nu, bool uPeriodic, int nv, bool vPeriodic, const <a class="el" href="namespaceIECore.html#a8831a05758aad0cc4f1968f74afdffca">IECore::PrimitiveVariableMap</a> &amp;primVars)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Render a patch mesh. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIECoreGL_1_1Renderer.html#a5568e3614f93fd7ec1cdb3f29387593f">geometry</a> (const std::string &amp;type, const <a class="el" href="namespaceIECore.html#ab8801f59558a8c67f526d7c9d730cdda">IECore::CompoundDataMap</a> &amp;topology, const <a class="el" href="namespaceIECore.html#a8831a05758aad0cc4f1968f74afdffca">IECore::PrimitiveVariableMap</a> &amp;primVars)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5d0ca2857df7cd8a958a9ed3d68916da"></a><!-- doxytag: member="IECoreGL::Renderer::procedural" ref="a5d0ca2857df7cd8a958a9ed3d68916da" args="(IECore::Renderer::ProceduralPtr proc)" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>procedural</b> (IECore::Renderer::ProceduralPtr proc)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac672c2299eedc9d26f054a3dd225f167"></a><!-- doxytag: member="IECoreGL::Renderer::instanceBegin" ref="ac672c2299eedc9d26f054a3dd225f167" args="(const std::string &amp;name, const IECore::CompoundDataMap &amp;parameters)" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIECoreGL_1_1Renderer.html#ac672c2299eedc9d26f054a3dd225f167">instanceBegin</a> (const std::string &amp;name, const <a class="el" href="namespaceIECore.html#ab8801f59558a8c67f526d7c9d730cdda">IECore::CompoundDataMap</a> &amp;parameters)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Starts the description of a portion of a scene to be instanced. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af9a0f751da42f4fa012cacc4f4442bbf"></a><!-- doxytag: member="IECoreGL::Renderer::instanceEnd" ref="af9a0f751da42f4fa012cacc4f4442bbf" args="()" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIECoreGL_1_1Renderer.html#af9a0f751da42f4fa012cacc4f4442bbf">instanceEnd</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Ends the description of an instance. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIECoreGL_1_1Renderer.html#a9ab720df63b3dc34284f73af94c23002">instance</a> (const std::string &amp;name)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual IECore::DataPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIECoreGL_1_1Renderer.html#a67587c2ea783f2a0029341b2ce05cfe6">command</a> (const std::string &amp;name, const <a class="el" href="namespaceIECore.html#ab8801f59558a8c67f526d7c9d730cdda">IECore::CompoundDataMap</a> &amp;parameters)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIECoreGL_1_1ShaderManager.html">ShaderManager</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIECoreGL_1_1Renderer.html#aeb1886b0cb925c8681a692b2135dd8e1">shaderManager</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIECoreGL_1_1TextureLoader.html">TextureLoader</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIECoreGL_1_1Renderer.html#aae8ca21f4b6e0bb05c1e4a29c97100ca">textureLoader</a> ()</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>The <a class="el" href="classIECoreGL_1_1Renderer.html">IECoreGL::Renderer</a> class implements the <a class="el" href="classIECore_1_1Renderer.html">IECore::Renderer</a> interface to allow rendering to OpenGL. Immediate mode rendering allows the generation of images and deferred mode rendering allows scenes to be captured for later interactive display. </p>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a1702c699dc0e41341f252ab7f8cacf52"></a><!-- doxytag: member="IECoreGL::Renderer::attributeBegin" ref="a1702c699dc0e41341f252ab7f8cacf52" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void IECoreGL::Renderer::attributeBegin </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Push a new attribute state onto the attribute stack. This is identical to the current state, but subsequent calls to <a class="el" href="classIECoreGL_1_1Renderer.html#a9b625028a444229dd7e9785b3b6ffd50">setAttribute()</a> will be discarded by the matching <a class="el" href="classIECoreGL_1_1Renderer.html#ad4ab5f30408dadb8b3e3b011d33ea295" title="Return to the attribute state saved by the last call to attributeBegin().">attributeEnd()</a>. </p>

<p>Implements <a class="el" href="classIECore_1_1Renderer.html#aa0db292a4c2ac8e06358d824082c885f">IECore::Renderer</a>.</p>

</div>
</div>
<a class="anchor" id="a7813f096d75df0e6341f2129c7706b74"></a><!-- doxytag: member="IECoreGL::Renderer::camera" ref="a7813f096d75df0e6341f2129c7706b74" args="(const std::string &amp;name, const IECore::CompoundDataMap &amp;parameters)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void IECoreGL::Renderer::camera </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceIECore.html#ab8801f59558a8c67f526d7c9d730cdda">IECore::CompoundDataMap</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>parameters</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="user"><dt><b>Standard parameters supported :</b></dt><dd></dd></dl>
<ul>
<li><b>"resolution"</b> </li>
<li><b>"projection"</b> (orthographic and perspective) </li>
<li><b>"projection:fov"</b> </li>
<li><b>"resolution"</b> </li>
<li><b>"screenWindow"</b> </li>
<li><b>"clippingPlanes"</b> </li>
</ul>

<p>Implements <a class="el" href="classIECore_1_1Renderer.html#a3faf858c0be8b8d54950c25bc5c15429">IECore::Renderer</a>.</p>

</div>
</div>
<a class="anchor" id="a67587c2ea783f2a0029341b2ce05cfe6"></a><!-- doxytag: member="IECoreGL::Renderer::command" ref="a67587c2ea783f2a0029341b2ce05cfe6" args="(const std::string &amp;name, const IECore::CompoundDataMap &amp;parameters)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual IECore::DataPtr IECoreGL::Renderer::command </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceIECore.html#ab8801f59558a8c67f526d7c9d730cdda">IECore::CompoundDataMap</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>parameters</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="user"><dt><b>Commands implemented</b></dt><dd></dd></dl>
<p>"removeObject"<br/>
 Expects a StringData parameter named "name", which specifies the name of an object to remove from the scene. This only has any effect in deferred mode. "editBegin"<br/>
 This parameter-less command marks the start of an edit to an existing scene, and should be called before any other changes are made when re-using an existing renderer, that has already reached worldEnd. "editEnd"<br/>
 This parameter-less command marks the end of an edit to an existing scene, and should be called after other changes have been made when re-using an existing renderer. Note that if a scene has been drawn with renderer-&gt;<a class="el" href="classIECoreGL_1_1Renderer.html#a472903d90b68dbffc1cc0e7e6df56cc0">scene()</a>-&gt;render() prior to this edit, then it is essential that editEnd is called by the same thread on which drawing was performed, so that GL resources can be released in the appropriate context. "editQuery"<br/>
 This parameter-less command returns BoolData( true ) if an edit is in progress, and BoolData( false ) otherwise. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000084">Todo:</a></b></dt><dd>Consider generalising an interface for scene edits and making it a standard part of the documentation in <a class="el" href="namespaceIECore.html" title="This namespace contains all components of the core library.">IECore</a>. Any such interface should take into account support for PRMan's new rerendering API. </dd></dl>

<p>Implements <a class="el" href="classIECore_1_1Renderer.html#af6002d21ab8243698183b8f4b7db1ae8">IECore::Renderer</a>.</p>

</div>
</div>
<a class="anchor" id="a2921243530c8ae0ba27508064b0969b6"></a><!-- doxytag: member="IECoreGL::Renderer::curves" ref="a2921243530c8ae0ba27508064b0969b6" args="(const IECore::CubicBasisf &amp;basis, bool periodic, IECore::ConstIntVectorDataPtr numVertices, const IECore::PrimitiveVariableMap &amp;primVars)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void IECoreGL::Renderer::curves </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIECore_1_1CubicBasis.html">IECore::CubicBasisf</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>basis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>periodic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IECore::ConstIntVectorDataPtr&nbsp;</td>
          <td class="paramname"> <em>numVertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceIECore.html#a8831a05758aad0cc4f1968f74afdffca">IECore::PrimitiveVariableMap</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>primVars</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Supports the following primitive variables :</p>
<p>Vertex V3fVectorData "P" Constant FloatData "width" </p>

</div>
</div>
<a class="anchor" id="a1f96f4eba40e94158ba76fe0392398ba"></a><!-- doxytag: member="IECoreGL::Renderer::disk" ref="a1f96f4eba40e94158ba76fe0392398ba" args="(float radius, float z, float thetaMax, const IECore::PrimitiveVariableMap &amp;primVars)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void IECoreGL::Renderer::disk </td>
          <td>(</td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>thetaMax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceIECore.html#a8831a05758aad0cc4f1968f74afdffca">IECore::PrimitiveVariableMap</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>primVars</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Renders a disk of the specified radius on the xy plane, at the specified z value. If the "rightHandedOrientation" attribute is true then the normal faces down positive z, otherwise it faces down negative z. </p>

<p>Implements <a class="el" href="classIECore_1_1Renderer.html#a12bb1618d491f2a9f21a1ddb9f1c5f3a">IECore::Renderer</a>.</p>

</div>
</div>
<a class="anchor" id="a7092ff8679776ee1218c451ac0b003c2"></a><!-- doxytag: member="IECoreGL::Renderer::display" ref="a7092ff8679776ee1218c451ac0b003c2" args="(const std::string &amp;name, const std::string &amp;type, const std::string &amp;data, const IECore::CompoundDataMap &amp;parameters)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void IECoreGL::Renderer::display </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceIECore.html#ab8801f59558a8c67f526d7c9d730cdda">IECore::CompoundDataMap</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>parameters</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Specifies an image to be output from the renderer. In the case of file outputs name specified the filename. type specifies the type of output to create and data specifies the data to be output, for instance "rgba". parameters provides an implementation specific set of parameters to control other aspects of the image created. It is only valid to call this before worldBegin. </p>

<p>Implements <a class="el" href="classIECore_1_1Renderer.html#a6701d3d585217ccdac915ac300b81130">IECore::Renderer</a>.</p>

</div>
</div>
<a class="anchor" id="a5568e3614f93fd7ec1cdb3f29387593f"></a><!-- doxytag: member="IECoreGL::Renderer::geometry" ref="a5568e3614f93fd7ec1cdb3f29387593f" args="(const std::string &amp;type, const IECore::CompoundDataMap &amp;topology, const IECore::PrimitiveVariableMap &amp;primVars)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void IECoreGL::Renderer::geometry </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceIECore.html#ab8801f59558a8c67f526d7c9d730cdda">IECore::CompoundDataMap</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>topology</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceIECore.html#a8831a05758aad0cc4f1968f74afdffca">IECore::PrimitiveVariableMap</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>primVars</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Supports the following geometry types with the specified topology data :</p>
<p>"sphere" "radius" FloatData 1 "zMin" FloatData -1 "zMax" FloatData 1 "thetaMax" FloatData 360</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000011">Deprecated:</a></b></dt><dd>Use the <a class="el" href="classIECoreGL_1_1Renderer.html#ab5cd828707163f7600e78925e973a5fe">sphere()</a> method instead. </dd></dl>

<p>Implements <a class="el" href="classIECore_1_1Renderer.html#a8019ffa4c48512bffea4b54b460dab9f">IECore::Renderer</a>.</p>

</div>
</div>
<a class="anchor" id="a2f72abed36e005957ace5b0134bf407b"></a><!-- doxytag: member="IECoreGL::Renderer::image" ref="a2f72abed36e005957ace5b0134bf407b" args="(const Imath::Box2i &amp;dataWindow, const Imath::Box2i &amp;displayWindow, const IECore::PrimitiveVariableMap &amp;primVars)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void IECoreGL::Renderer::image </td>
          <td>(</td>
          <td class="paramtype">const Imath::Box2i &amp;&nbsp;</td>
          <td class="paramname"> <em>dataWindow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Imath::Box2i &amp;&nbsp;</td>
          <td class="paramname"> <em>displayWindow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceIECore.html#a8831a05758aad0cc4f1968f74afdffca">IECore::PrimitiveVariableMap</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>primVars</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Supports the following image formats specified as primitive variables :</p>
<p>"R", "G", "B", "A" : UCharVectorData "R", "G", "B", "A" : CharVectorData "R", "G", "B", "A" : UIntVectorData "R", "G", "B", "A" : IntVectorData "R", "G", "B", "A" : HalfVectorData "R", "G", "B", "A" : FloatVectorData "R", "G", "B", "A" : DoubleVectorData</p>
<p>As a convenience the names "r", "g", "b", "a" or "red", "green", "blue", "alpha" can appear in place of "R", "G", "B", "A".</p>
<p>Currently assumes dataWindow==displayWindow. </p>

<p>Implements <a class="el" href="classIECore_1_1Renderer.html#ab72852161207aa3efda6d5c9b692fdd3">IECore::Renderer</a>.</p>

</div>
</div>
<a class="anchor" id="a9ab720df63b3dc34284f73af94c23002"></a><!-- doxytag: member="IECoreGL::Renderer::instance" ref="a9ab720df63b3dc34284f73af94c23002" args="(const std::string &amp;name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void IECoreGL::Renderer::instance </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Instantiates a previously described instance at the current transform position, and using the current attribute state. </p>

<p>Implements <a class="el" href="classIECore_1_1Renderer.html#a647895f399319f4cbb5540934f6a8405">IECore::Renderer</a>.</p>

</div>
</div>
<a class="anchor" id="ac400555b5fa076f374b9ce54b48817f0"></a><!-- doxytag: member="IECoreGL::Renderer::mesh" ref="ac400555b5fa076f374b9ce54b48817f0" args="(IECore::ConstIntVectorDataPtr vertsPerFace, IECore::ConstIntVectorDataPtr vertIds, const std::string &amp;interpolation, const IECore::PrimitiveVariableMap &amp;primVars)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void IECoreGL::Renderer::mesh </td>
          <td>(</td>
          <td class="paramtype">IECore::ConstIntVectorDataPtr&nbsp;</td>
          <td class="paramname"> <em>vertsPerFace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IECore::ConstIntVectorDataPtr&nbsp;</td>
          <td class="paramname"> <em>vertIds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>interpolation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceIECore.html#a8831a05758aad0cc4f1968f74afdffca">IECore::PrimitiveVariableMap</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>primVars</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>All meshes are treated as having interpolation=="linear". </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000083">Todo:</a></b></dt><dd>Support normals and st. </dd></dl>

</div>
</div>
<a class="anchor" id="aa7b461b99a59a7802e90584aa15723cd"></a><!-- doxytag: member="IECoreGL::Renderer::motionBegin" ref="aa7b461b99a59a7802e90584aa15723cd" args="(const std::set&lt; float &gt; &amp;times)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void IECoreGL::Renderer::motionBegin </td>
          <td>(</td>
          <td class="paramtype">const std::set&lt; float &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>times</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Starts a new motion block. You should then make times.size() calls to one of the primitive or transform functions to specify the motion for the block. </p>

<p>Implements <a class="el" href="classIECore_1_1Renderer.html#a1468320b6f166544a1a1193eb25365be">IECore::Renderer</a>.</p>

</div>
</div>
<a class="anchor" id="a87b230e64de868cde14245016251f3c9"></a><!-- doxytag: member="IECoreGL::Renderer::motionEnd" ref="a87b230e64de868cde14245016251f3c9" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void IECoreGL::Renderer::motionEnd </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Ends a motion block. Should be called when times.size() calls to an appropriate primitive or transform function have been made following a <a class="el" href="classIECoreGL_1_1Renderer.html#aa7b461b99a59a7802e90584aa15723cd">motionBegin()</a> call. </p>

<p>Implements <a class="el" href="classIECore_1_1Renderer.html#aa195e2e8ec823abfa2ba9e08ed328149">IECore::Renderer</a>.</p>

</div>
</div>
<a class="anchor" id="a73a9c38b0646edfd9b4124851c28c122"></a><!-- doxytag: member="IECoreGL::Renderer::points" ref="a73a9c38b0646edfd9b4124851c28c122" args="(size_t numPoints, const IECore::PrimitiveVariableMap &amp;primVars)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void IECoreGL::Renderer::points </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>numPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceIECore.html#a8831a05758aad0cc4f1968f74afdffca">IECore::PrimitiveVariableMap</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>primVars</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Supports the following primitive variables :</p>
<p>Vertex V3fVectorData "P"</p>
<p>Uniform StringData "type" Used to determine how the points are rendered. Supported types are :</p>
<p>"gl:point" Rendered as GL_POINTS</p>
<p>"particle" (the default) "disk" "blobby" Rendered as camera facing disks. The "width" and "constantwidth" variables are supported. Blobby is provided for vague compatibility with the IECoreRI::RIRenderer and 3delight.</p>
<p>"patch" Rendered as camera facing patches. Supports the "width" and "constantwidth" variables and in addition the "patchaspectratio" and "patchrotation" variables. See the 3delight documentation for a description of how these can be used.</p>
<p>"sphere" Rendered as spheres. Supports "width" and "constantwidth" variables to define the sizes of the spheres.</p>
<p>Constant FloatData "constantwidth"</p>
<p>Vertex|Varying FloatVectorData "width"</p>
<p>Constant|Vertex|Varying FloatData|FloatVectorData "patchaspectratio" Constant|Vertex|Varying FloatData|FloatVectorData "patchrotation" These two are used only by the "patch" type. </p>

<p>Implements <a class="el" href="classIECore_1_1Renderer.html#a06ef00615a53a48bfdfbe1e48669d836">IECore::Renderer</a>.</p>

</div>
</div>
<a class="anchor" id="a472903d90b68dbffc1cc0e7e6df56cc0"></a><!-- doxytag: member="IECoreGL::Renderer::scene" ref="a472903d90b68dbffc1cc0e7e6df56cc0" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ScenePtr IECoreGL::Renderer::scene </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>When in deferred mode (see setOption above), this method will return the Scene that was generated. </p>
<dl class="user"><dt><b>Threading:</b></dt><dd>The <a class="el" href="classIECoreGL_1_1Renderer.html">Renderer</a> tries very hard not to need a GL context to operate in when in deferred mode. This allows it to evaluate multiple procedurals concurrently in separate threads (GL wants only one threading talking to a context). When the scene is rendered for the first time it will instantiate various OpenGL resources (textures and shaders and the like) in the current GL context. It is therefore important that the scene is destroyed from the same thread that renders it, so that the resources are released in the correct context. As the resources are also shared by caches (TextureLoaders and ShaderManagers) in the <a class="el" href="classIECoreGL_1_1Renderer.html">Renderer</a>, it is also important that the renderer is destroyed from this same thread. </dd></dl>

</div>
</div>
<a class="anchor" id="a9b625028a444229dd7e9785b3b6ffd50"></a><!-- doxytag: member="IECoreGL::Renderer::setAttribute" ref="a9b625028a444229dd7e9785b3b6ffd50" args="(const std::string &amp;name, IECore::ConstDataPtr value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void IECoreGL::Renderer::setAttribute </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IECore::ConstDataPtr&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="user"><dt><b>Standard attributes supported : </b></dt><dd></dd></dl>
<ul>
<li><b>"color"</b><br/>
 Sets the rgb components of the current OpenGL color. </li>
<li><b>"opacity"</b><br/>
 Sets the alpha component of the current OpenGL color to the average of the rgb components of opacity.</li>
</ul>
<ul>
<li><b>"doubleSided"</b> </li>
<li><b>"rightHandedOrientation"</b> </li>
<li><b>"name"</b></li>
</ul>
<ul>
<li><b>"user:*"</b></li>
</ul>
<dl class="user"><dt><b>Implementation specific attributes :</b></dt><dd></dd></dl>
<ul>
<li><b>"gl:color" Color4fData Color4f( 1.0f )</b> Sets the current OpenGL color including the alpha component.</li>
</ul>
<dl class="user"><dt><b>Implementation specific shading attributes :</b></dt><dd></dd></dl>
<ul>
<li><b>"gl:shade:transparent" BoolData false</b><br/>
 Signifies that shading may result in transparent results. This is necessary as it's nontrivial to determine this information by querying the shader, and other parts of the system may need to know when transparency is present - for example to trigger depth sorting.</li>
</ul>
<dl class="user"><dt><b>Implementation specific primitive style attributes :</b></dt><dd></dd></dl>
<ul>
<li><b>"gl:primitive:wireframe" BoolData false</b><br/>
 Draw a wireframe for each primitive.</li>
</ul>
<ul>
<li><b>"gl:primitive:wireframeWidth" FloatData 1.0f</b><br/>
 The line width of the wireframe of the primitive.</li>
</ul>
<ul>
<li><b>"gl:primitive:wireframeColor" Color4fData</b><br/>
 The color of the wireframes drawn.</li>
</ul>
<ul>
<li><b>"gl:primitive:bound" BoolData false</b><br/>
 Draw a bounding box for each primitive.</li>
</ul>
<ul>
<li><b>"gl:primitive:boundColor" Color4fData </b><br/>
 The color of the bounding boxes drawn.</li>
</ul>
<ul>
<li><b>"gl:primitive:solid" BoolData true</b><br/>
 Draw each primitive solid.</li>
</ul>
<ul>
<li><b>"gl:primitive:outline" BoolData false</b><br/>
 Draw an outline for each primitive. Note that the results of having this on with filled mode off will probably be undesirable.</li>
</ul>
<ul>
<li><b>"gl:primitive:outlineColor" Color4fData</b><br/>
 The color of the outlines drawn.</li>
</ul>
<ul>
<li><b>"gl:primitive:outlineWidth" FloatData 1.0f</b><br/>
 The line width of the outlines of the primitive.</li>
</ul>
<ul>
<li><b>"gl:primitive:points" BoolData false</b><br/>
 Draw the vertices of each primitive as points.</li>
</ul>
<ul>
<li><b>"gl:primitive:pointWidth" FloatData 1.0f</b><br/>
 The width of the points used to draw vertices.</li>
</ul>
<ul>
<li><b>"gl:primitive:pointColor" Color4fData</b><br/>
 The color of the points drawn.</li>
</ul>
<ul>
<li><b>"gl:primitive:sortForTransparency" BoolData true</b><br/>
 Causes the individual components of a primitive to be sorted in depth when the "gl:shade:transparent" attribute is true. This is currently supported only by the points primitive.</li>
</ul>
<dl class="user"><dt><b>Implementation specific points primitive attributes :</b></dt><dd></dd></dl>
<ul>
<li><b>"gl:pointsPrimitive:useGLPoints" StringData "forGLPoints"</b><br/>
 Can be used to force the use of lightweight glPoints representation of points primitives with types other than "gl:point". Valid values are :<br/>
<br/>
 "forGLPoints"<br/>
 Use lightweight points only if type is "gl:point"<br/>
<br/>
 "forParticlesAndDisks"<br/>
 Use lightweight points as a stand in for particle and disk types.<br/>
<br/>
 "forAll"<br/>
 Use lightweight points as a stand in for all point types. <br/>
<br/>
</li>
</ul>
<ul>
<li><b>"gl:pointsPrimitive:glPointWidth" FloatData 1.0f</b><br/>
 The size of the points (in pixels) used when rendering lightweight points.</li>
</ul>
<dl class="user"><dt><b>Implementation specific curves primitive attributes :</b></dt><dd></dd></dl>
<ul>
<li><b>"gl:curvesPrimitive:useGLLines" BoolData false</b><br/>
 When this is true then lightweight OpenGL line primitives are used for representing curves.</li>
</ul>
<ul>
<li><b>"gl:curvesPrimitive:glLineWidth" FloatData 1.0f</b><br/>
 Specifies the line width (in pixels) which is used when rendering lightweight line primitives.</li>
</ul>
<ul>
<li><b>"gl:curvesPrimitive:ignoreBasis" BoolData false</b><br/>
 When this is true, all curves are rendered as if they were linear.</li>
</ul>
<dl class="user"><dt><b>Implementation specific text primitive attributes :</b></dt><dd></dd></dl>
<ul>
<li><b>"gl:textPrimitive:type" StringData "mesh"</b><br/>
 Controls the basic method used for text rendering. A value of "mesh" specifies that text primitives are rendered as triangulated meshes, and a value of "sprite" specifies rendering as textured planes. The former allows completely customisable shading using the current shader, whereas the latter is shaded constantly using the current colour, but may offer better anti-aliasing and/or speed.</li>
</ul>
<dl class="user"><dt><b>Implementation specific blending attributes :</b></dt><dd></dd></dl>
<ul>
<li><b>"gl:blend:srcFactor" StringData "srcAlpha"</b><br/>
 </li>
<li><b>"gl:blend:dstFactor" StringData "oneMinusSrcAlpha"</b><br/>
 These attributes are mapped onto calls to glBlendFunc. They accept only the values below, which correspond directly to one of the GLenum blending values.<br/>
<br/>
 "zero"<br/>
 "one"<br/>
 "srcColor"<br/>
 "oneMinusSrcColor"<br/>
 "dstColor"<br/>
 "oneMinusDstColor"<br/>
 "srcAlpha"<br/>
 "oneMinusSrcAlpha"<br/>
 "dstAlpha"<br/>
 "oneMinusDstAlpha"<br/>
 "constantColor"<br/>
 "oneMinusConstantColor"<br/>
 "constantAlpha"<br/>
 "oneMinusConstantAlpha"<br/>
</li>
</ul>
<ul>
<li><b>"gl:blend:color" Color4fData 1 1 1 1</b><br/>
 Used to specify glBlendColor(), only taking effect when using either "constantColor" or "oneMinusConstantColor" for one or other of the blend factors above.</li>
</ul>
<ul>
<li><b>"gl:blend:equation" StringData "add"</b><br/>
 Controls how the src and dst values are combined after being weighted by srcFactor and dstFactor - this maps onto a call to glBlendEquation. Valid values are listed below, and map directly onto the corresponding GLenum values.<br/>
<br/>
 "add"<br/>
 "subtract"<br/>
 "reverseSubtract"<br/>
 "min"<br/>
 "max"<br/>
</li>
</ul>
<dl class="user"><dt><b>Implementation specific antialiasing attributes :</b></dt><dd></dd></dl>
<ul>
<li><b>"gl:smoothing:points" BoolData false</b><br/>
 </li>
<li><b>"gl:smoothing:lines" BoolData false</b><br/>
 </li>
<li><b>"gl:smoothing:polygons" BoolData false</b><br/>
 These attributes enable GL_POINT_SMOOTH, GL_LINE_SMOOTH and GL_POLYGON_SMOOTH respectively.</li>
</ul>
<dl class="user"><dt><b>Implementation specific procedural attributes :</b></dt><dd></dd></dl>
<ul>
<li><b>"gl:procedural:reentrant" BoolData true</b><br/>
 When true, procedurals may be evaluated in multiple parallel threads. When false they will be evaluated from the same thread they were specified from. <dl class="user"><dt><b>Implementation specific depth buffer attributes :</b></dt><dd></dd></dl>
</li>
<li><b>"gl:depthTest" BoolData true</b><br/>
 Maps to glEnable/Disable GL_DEPTH_TEST</li>
</ul>
<dl class="user"><dt><b>Implementation specific visibility attributes :</b></dt><dd></dd></dl>
<ul>
<li><b>"gl:visibility:camera" BoolData true</b><br/>
 Specifies whether or not objects are visible to the camera. If a procedural is not visible then it will not be opened to discover if it's contents might turn visibility back on. </li>
</ul>

</div>
</div>
<a class="anchor" id="a3615f6f7c8edd15173a8c51b142cd32d"></a><!-- doxytag: member="IECoreGL::Renderer::setOption" ref="a3615f6f7c8edd15173a8c51b142cd32d" args="(const std::string &amp;name, IECore::ConstDataPtr value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void IECoreGL::Renderer::setOption </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IECore::ConstDataPtr&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="user"><dt><b>Standard options supported :</b></dt><dd></dd></dl>
<ul>
<li><b>"searchPath:font"</b></li>
</ul>
<dl class="user"><dt><b>Implementation specific options supported :</b></dt><dd></dd></dl>
<p>"gl:mode" StringData Valid values are "immediate" or "deferred". In immediate mode rendering is performed in a streaming fashion, drawing each primitive as it is specified. In deferred mode rendering is performed by building a Scene object which can be retrieved for further use by using the <a class="el" href="classIECoreGL_1_1Renderer.html#a472903d90b68dbffc1cc0e7e6df56cc0">scene()</a> method after the render is complete. Future versions may support advanced features such as motion blur and depth of field when in deferred mode but not in immediate mode.</p>
<p>"searchPath:shader" StringData "gl:searchPath:shader" StringData Specifies a set of colon separated paths on which to search for GLSL shaders. The default value is obtained from the environment variable IECOREGL_SHADER_PATHS.</p>
<p>"searchPath:shaderInclude" StringData "gl:searchPath:shaderInclude" StringData Specifies a set of colon separated paths on which to search for include files for GLSL shaders. The default value is obtained from the environment variable IECOREGL_SHADER_INCLUDE_PATHS.</p>
<p>"searchPath:texture" StringData "gl:searchPath:texture" StringData Specifies a set of colon separated paths on which to search for textures. The default value is obtained from the environment variable IECOREGL_TEXTURE_PATHS. Any image file format for which an <a class="el" href="classIECore_1_1Reader.html">IECore::Reader</a> is available is suitable for use as a texture.</p>
<p>"shutter" V2fData</p>
<p>"gl:drawCoordinateSystems" BoolData false When this is true, coordinate systems created with the <a class="el" href="classIECoreGL_1_1Renderer.html#a86c5d85db533319b0df9c2a642ce8951" title="Creates a named coordinate system from the current transform.">coordinateSystem()</a> method will be visualised. </p>

</div>
</div>
<a class="anchor" id="a8c3962236748aa6efa8e0f0e9017267a"></a><!-- doxytag: member="IECoreGL::Renderer::setTransform" ref="a8c3962236748aa6efa8e0f0e9017267a" args="(const std::string &amp;coordinateSystem)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void IECoreGL::Renderer::setTransform </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>coordinateSystem</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets the current transform to a coordinate system previously created with a call to <a class="el" href="classIECoreGL_1_1Renderer.html#a86c5d85db533319b0df9c2a642ce8951" title="Creates a named coordinate system from the current transform.">coordinateSystem()</a>. </p>

<p>Implements <a class="el" href="classIECore_1_1Renderer.html#ae40039c9e135edc5250f9ab709af56d5">IECore::Renderer</a>.</p>

</div>
</div>
<a class="anchor" id="ac6134c40f82af161fcb95ec2a8a68068"></a><!-- doxytag: member="IECoreGL::Renderer::shader" ref="ac6134c40f82af161fcb95ec2a8a68068" args="(const std::string &amp;type, const std::string &amp;name, const IECore::CompoundDataMap &amp;parameters)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void IECoreGL::Renderer::shader </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceIECore.html#ab8801f59558a8c67f526d7c9d730cdda">IECore::CompoundDataMap</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>parameters</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Supports only shader type "surface" or "gl:surface", looking for "name.vert" and "name.frag" GLSL source files in the paths defined by the "searchPath:shader" option. Alternatively if the parameter list contains "gl:vertexSource" and/or a "gl:fragmentSource" StringData then a new shader is created using the source provided. For shaders with sampler2D parameters, texture files for these parameters may be specified by passing the filename to an image as StringData. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000082">Todo:</a></b></dt><dd>Add support for "textureParameterName:filter" and "textureParameterName:wrap" parameters which set wrapping and filtering on a <a class="el" href="classIECoreGL_1_1ShaderStateComponent.html">ShaderStateComponent</a>. </dd></dl>

<p>Implements <a class="el" href="classIECore_1_1Renderer.html#a5f5a34ede04a128db9db2240b50e6bad">IECore::Renderer</a>.</p>

</div>
</div>
<a class="anchor" id="aeb1886b0cb925c8681a692b2135dd8e1"></a><!-- doxytag: member="IECoreGL::Renderer::shaderManager" ref="aeb1886b0cb925c8681a692b2135dd8e1" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIECoreGL_1_1ShaderManager.html">ShaderManager</a>* IECoreGL::Renderer::shaderManager </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the internal <a class="el" href="classIECoreGL_1_1ShaderManager.html">ShaderManager</a> object used to manage the shaders from this renderer. If called before worldBegin it returns 0. </p>

</div>
</div>
<a class="anchor" id="ab5cd828707163f7600e78925e973a5fe"></a><!-- doxytag: member="IECoreGL::Renderer::sphere" ref="ab5cd828707163f7600e78925e973a5fe" args="(float radius, float zMin, float zMax, float thetaMax, const IECore::PrimitiveVariableMap &amp;primVars)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void IECoreGL::Renderer::sphere </td>
          <td>(</td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>zMin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>zMax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>thetaMax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceIECore.html#a8831a05758aad0cc4f1968f74afdffca">IECore::PrimitiveVariableMap</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>primVars</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Renders a sphere of the specified radius. zMin and zMax are measured as a proportion of the radius - so no matter what the radius, the default values will always give a full sphere. If the "rightHandedOrientation" attribute is true then the normals point outwards, otherwise they point inwards. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000050">Todo:</a></b></dt><dd>Give this the default values it talks about. </dd></dl>

<p>Implements <a class="el" href="classIECore_1_1Renderer.html#a94869f43c647947b0ca88c8b527c2a58">IECore::Renderer</a>.</p>

</div>
</div>
<a class="anchor" id="aae8ca21f4b6e0bb05c1e4a29c97100ca"></a><!-- doxytag: member="IECoreGL::Renderer::textureLoader" ref="aae8ca21f4b6e0bb05c1e4a29c97100ca" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIECoreGL_1_1TextureLoader.html">TextureLoader</a>* IECoreGL::Renderer::textureLoader </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the internal <a class="el" href="classIECoreGL_1_1TextureLoader.html">TextureLoader</a> object. If called before worldBegin it returns 0. </p>

</div>
</div>
<a class="anchor" id="a366d44018791c93e3049f87b94d7c99a"></a><!-- doxytag: member="IECoreGL::Renderer::transformBegin" ref="a366d44018791c93e3049f87b94d7c99a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void IECoreGL::Renderer::transformBegin </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Push a new transform state identical to the current one. Modifications can then be made locally before calling <a class="el" href="classIECoreGL_1_1Renderer.html#aa8344717cb99ff7cf8833c541e644684" title="Returns to the transform state saved by the last transformBegin() call.">transformEnd()</a> to return to the previous transform state. </p>

<p>Implements <a class="el" href="classIECore_1_1Renderer.html#a8de999de675f13ad6b0c75aef9507508">IECore::Renderer</a>.</p>

</div>
</div>
<a class="anchor" id="a34105398ff19bb8267e585b47abfe1f1"></a><!-- doxytag: member="IECoreGL::Renderer::worldBegin" ref="a34105398ff19bb8267e585b47abfe1f1" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void IECoreGL::Renderer::worldBegin </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Starts the world block and resets the current transform to the identity. </p>

<p>Implements <a class="el" href="classIECore_1_1Renderer.html#ae525ed886ed90f3286c412d3c3ad1503">IECore::Renderer</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/IECoreGL/<a class="el" href="L_2Renderer_8h_source.html">Renderer.h</a></li>
</ul>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&nbsp;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&nbsp;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&nbsp;</span>Friends</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr size="1"/><address style="text-align: right;"><small>Generated on 5 Jan 2012 for Cortex by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
