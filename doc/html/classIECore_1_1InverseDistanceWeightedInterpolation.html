<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Cortex: IECore::InverseDistanceWeightedInterpolation&lt; PointIterator, ValueIterator &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.6.1 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<script type="text/javascript">
<!--
function changeDisplayState (e){
  var num=this.id.replace(/[^[0-9]/g,'');
  var button=this.firstChild;
  var sectionDiv=document.getElementById('dynsection'+num);
  if (sectionDiv.style.display=='none'||sectionDiv.style.display==''){
    sectionDiv.style.display='block';
    button.src='open.gif';
  }else{
    sectionDiv.style.display='none';
    button.src='closed.gif';
  }
}
function initDynSections(){
  var divs=document.getElementsByTagName('div');
  var sectionCounter=1;
  for(var i=0;i<divs.length-1;i++){
    if(divs[i].className=='dynheader'&&divs[i+1].className=='dynsection'){
      var header=divs[i];
      var section=divs[i+1];
      var button=header.firstChild;
      if (button!='IMG'){
        divs[i].insertBefore(document.createTextNode(' '),divs[i].firstChild);
        button=document.createElement('img');
        divs[i].insertBefore(button,divs[i].firstChild);
      }
      header.style.cursor='pointer';
      header.onclick=changeDisplayState;
      header.id='dynheader'+sectionCounter;
      button.src='closed.gif';
      section.id='dynsection'+sectionCounter;
      section.style.display='none';
      section.style.marginLeft='14px';
      sectionCounter++;
    }
  }
}
window.onload = initDynSections;
-->
</script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <img id="MSearchSelect" src="search/search.png"
             onmouseover="return searchBox.OnSearchSelectShow()"
             onmouseout="return searchBox.OnSearchSelectHide()"
             alt=""/>
        <input type="text" id="MSearchField" value="Search" accesskey="S"
             onfocus="searchBox.OnSearchFieldFocus(true)" 
             onblur="searchBox.OnSearchFieldFocus(false)" 
             onkeyup="searchBox.OnSearchFieldChange(event)"/>
        <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
        </div>
      </li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="namespaceIECore.html">IECore</a>::<a class="el" href="classIECore_1_1InverseDistanceWeightedInterpolation.html">InverseDistanceWeightedInterpolation</a>
  </div>
</div>
<div class="contents">
<h1>IECore::InverseDistanceWeightedInterpolation&lt; PointIterator, ValueIterator &gt; Class Template Reference<br/>
<small>
[<a class="el" href="group__mathGroup.html">Math</a>]</small>
</h1><!-- doxytag: class="IECore::InverseDistanceWeightedInterpolation" -->
<p><code>#include &lt;<a class="el" href="InverseDistanceWeightedInterpolation_8h_source.html">InverseDistanceWeightedInterpolation.h</a>&gt;</code></p>

<p><a href="classIECore_1_1InverseDistanceWeightedInterpolation-members.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a06ee6684ddd7039c3bdb2e2a16b384e4"></a><!-- doxytag: member="IECore::InverseDistanceWeightedInterpolation::Point" ref="a06ee6684ddd7039c3bdb2e2a16b384e4" args="" -->
typedef std::iterator_traits<br class="typebreak"/>
&lt; PointIterator &gt;::value_type&nbsp;</td><td class="memItemRight" valign="bottom"><b>Point</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a577426007c5bc4756249fc06b5d0a193"></a><!-- doxytag: member="IECore::InverseDistanceWeightedInterpolation::PointBaseType" ref="a577426007c5bc4756249fc06b5d0a193" args="" -->
typedef <a class="el" href="structIECore_1_1VectorTraits.html">VectorTraits</a>&lt; Point &gt;<br class="typebreak"/>
::BaseType&nbsp;</td><td class="memItemRight" valign="bottom"><b>PointBaseType</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeb87408b3290faf78895a9c00fbff554"></a><!-- doxytag: member="IECore::InverseDistanceWeightedInterpolation::Tree" ref="aeb87408b3290faf78895a9c00fbff554" args="" -->
typedef <a class="el" href="classIECore_1_1KDTree.html">KDTree</a>&lt; PointIterator &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>Tree</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a840b773199bc88b1bd596ef16072f5da"></a><!-- doxytag: member="IECore::InverseDistanceWeightedInterpolation::NeighbourVector" ref="a840b773199bc88b1bd596ef16072f5da" args="" -->
typedef std::vector&lt; typename <br class="typebreak"/>
<a class="el" href="classIECore_1_1KDTree_1_1Neighbour.html">Tree::Neighbour</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>NeighbourVector</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a875aec0d520be475a0b5a5a07c7bf509"></a><!-- doxytag: member="IECore::InverseDistanceWeightedInterpolation::Value" ref="a875aec0d520be475a0b5a5a07c7bf509" args="" -->
typedef std::iterator_traits<br class="typebreak"/>
&lt; ValueIterator &gt;::value_type&nbsp;</td><td class="memItemRight" valign="bottom"><b>Value</b></td></tr>
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIECore_1_1InverseDistanceWeightedInterpolation.html#afad9208d4fa593225a0ccbb7cfb9130a">InverseDistanceWeightedInterpolation</a> (PointIterator firstPoint, PointIterator lastPoint, ValueIterator firstValue, ValueIterator lastValue, unsigned int numNeighbours, int maxLeafSize=4)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a194de93023fdb7be34bdde2037a04565"></a><!-- doxytag: member="IECore::InverseDistanceWeightedInterpolation::operator()" ref="a194de93023fdb7be34bdde2037a04565" args="(const Point &amp;p) const " -->
Value&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIECore_1_1InverseDistanceWeightedInterpolation.html#a194de93023fdb7be34bdde2037a04565">operator()</a> (const Point &amp;p) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Evaluate the interpolated value for the specified point. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Value&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIECore_1_1InverseDistanceWeightedInterpolation.html#a87e870f73bf56f13a02cc86b1d9733ba">operator()</a> (const Point &amp;p, NeighbourVector &amp;neighbours) const </td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;typename PointIterator, typename ValueIterator&gt;<br/>
 class IECore::InverseDistanceWeightedInterpolation&lt; PointIterator, ValueIterator &gt;</h3>

<p>The <a class="el" href="classIECore_1_1InverseDistanceWeightedInterpolation.html">InverseDistanceWeightedInterpolation</a> class provides interpolation of scattered data. It is templated so that it can operate on a wide variety of point/value types. NB. The Value must be default constructible, and define sensible value=value+value, and value=value*scalar operators </p>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="afad9208d4fa593225a0ccbb7cfb9130a"></a><!-- doxytag: member="IECore::InverseDistanceWeightedInterpolation::InverseDistanceWeightedInterpolation" ref="afad9208d4fa593225a0ccbb7cfb9130a" args="(PointIterator firstPoint, PointIterator lastPoint, ValueIterator firstValue, ValueIterator lastValue, unsigned int numNeighbours, int maxLeafSize=4)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointIterator , typename ValueIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIECore_1_1InverseDistanceWeightedInterpolation.html">IECore::InverseDistanceWeightedInterpolation</a>&lt; PointIterator, ValueIterator &gt;::<a class="el" href="classIECore_1_1InverseDistanceWeightedInterpolation.html">InverseDistanceWeightedInterpolation</a> </td>
          <td>(</td>
          <td class="paramtype">PointIterator&nbsp;</td>
          <td class="paramname"> <em>firstPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PointIterator&nbsp;</td>
          <td class="paramname"> <em>lastPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ValueIterator&nbsp;</td>
          <td class="paramname"> <em>firstValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ValueIterator&nbsp;</td>
          <td class="paramname"> <em>lastValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>numNeighbours</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>maxLeafSize</em> = <code>4</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Creates the interpolator. Note that it does not own the passed points or values - it is up to you to ensure that they remain valid and unchanged as long as the interpolator is in use. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>firstPoint</em>&nbsp;</td><td>RandomAccessIterator to first point </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>lastPoint</em>&nbsp;</td><td>RandomAccessIterator to last point </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>firstValue</em>&nbsp;</td><td>RandomAccessIterator to first value </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>lastValue</em>&nbsp;</td><td>RandomAccessIterator to last value </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>numNeighbours</em>&nbsp;</td><td>The amount of nearest-neighbour points to consider when performing interpolation. More usually yields slower, but better results. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>maxLeafSize</em>&nbsp;</td><td>The number of points to store in each <a class="el" href="classIECore_1_1KDTree.html">KDTree</a> bucket </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a87e870f73bf56f13a02cc86b1d9733ba"></a><!-- doxytag: member="IECore::InverseDistanceWeightedInterpolation::operator()" ref="a87e870f73bf56f13a02cc86b1d9733ba" args="(const Point &amp;p, NeighbourVector &amp;neighbours) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointIterator , typename ValueIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Value <a class="el" href="classIECore_1_1InverseDistanceWeightedInterpolation.html">IECore::InverseDistanceWeightedInterpolation</a>&lt; PointIterator, ValueIterator &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const Point &amp;&nbsp;</td>
          <td class="paramname"> <em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NeighbourVector &amp;&nbsp;</td>
          <td class="paramname"> <em>neighbours</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>As above, but returning information about which neighbours contributed to the result. Note that for repeated queries it is quicker to call this method reusing the same NeighbourVector than it is to call the version above, which has to allocate a NeighbourVector each time. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/IECore/<a class="el" href="InverseDistanceWeightedInterpolation_8h_source.html">InverseDistanceWeightedInterpolation.h</a></li>
</ul>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&nbsp;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&nbsp;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&nbsp;</span>Friends</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr size="1"/><address style="text-align: right;"><small>Generated on 5 Jan 2012 for Cortex by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
