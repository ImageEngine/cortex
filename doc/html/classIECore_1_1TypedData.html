<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Cortex: IECore::TypedData&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.6.1 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<script type="text/javascript">
<!--
function changeDisplayState (e){
  var num=this.id.replace(/[^[0-9]/g,'');
  var button=this.firstChild;
  var sectionDiv=document.getElementById('dynsection'+num);
  if (sectionDiv.style.display=='none'||sectionDiv.style.display==''){
    sectionDiv.style.display='block';
    button.src='open.gif';
  }else{
    sectionDiv.style.display='none';
    button.src='closed.gif';
  }
}
function initDynSections(){
  var divs=document.getElementsByTagName('div');
  var sectionCounter=1;
  for(var i=0;i<divs.length-1;i++){
    if(divs[i].className=='dynheader'&&divs[i+1].className=='dynsection'){
      var header=divs[i];
      var section=divs[i+1];
      var button=header.firstChild;
      if (button!='IMG'){
        divs[i].insertBefore(document.createTextNode(' '),divs[i].firstChild);
        button=document.createElement('img');
        divs[i].insertBefore(button,divs[i].firstChild);
      }
      header.style.cursor='pointer';
      header.onclick=changeDisplayState;
      header.id='dynheader'+sectionCounter;
      button.src='closed.gif';
      section.id='dynsection'+sectionCounter;
      section.style.display='none';
      section.style.marginLeft='14px';
      sectionCounter++;
    }
  }
}
window.onload = initDynSections;
-->
</script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <img id="MSearchSelect" src="search/search.png"
             onmouseover="return searchBox.OnSearchSelectShow()"
             onmouseout="return searchBox.OnSearchSelectHide()"
             alt=""/>
        <input type="text" id="MSearchField" value="Search" accesskey="S"
             onfocus="searchBox.OnSearchFieldFocus(true)" 
             onblur="searchBox.OnSearchFieldFocus(false)" 
             onkeyup="searchBox.OnSearchFieldChange(event)"/>
        <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
        </div>
      </li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="namespaceIECore.html">IECore</a>::<a class="el" href="classIECore_1_1TypedData.html">TypedData</a>
  </div>
</div>
<div class="contents">
<h1>IECore::TypedData&lt; T &gt; Class Template Reference<br/>
<small>
[<a class="el" href="group__coreGroup.html">Core</a>]</small>
</h1><!-- doxytag: class="IECore::TypedData" --><!-- doxytag: inherits="IECore::Data" -->
<p><code>#include &lt;<a class="el" href="TypedData_8h_source.html">TypedData.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for IECore::TypedData&lt; T &gt;:</div>
<div class="dynsection">
 <div class="center">
  <img src="classIECore_1_1TypedData.gif" usemap="#IECore::TypedData&lt; T &gt;_map" alt=""/>
  <map id="IECore::TypedData&lt; T &gt;_map" name="IECore::TypedData&lt; T &gt;_map">
<area href="classIECore_1_1Data.html" alt="IECore::Data" shape="rect" coords="0,168,177,192"/>
<area href="classIECore_1_1Object.html" alt="IECore::Object" shape="rect" coords="0,112,177,136"/>
<area href="classIECore_1_1RunTimeTyped.html" alt="IECore::RunTimeTyped" shape="rect" coords="0,56,177,80"/>
<area href="classIECore_1_1RefCounted.html" alt="IECore::RefCounted" shape="rect" coords="0,0,177,24"/>
<area href="classIECore_1_1LongVectorDataAlias.html" alt="IECore::LongVectorDataAlias" shape="rect" coords="0,280,177,304"/>
</map>
 </div>
</div>

<p><a href="classIECore_1_1TypedData-members.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4491deeface1a84918b3e4b68eba84dd"></a><!-- doxytag: member="IECore::TypedData::ValueType" ref="a4491deeface1a84918b3e4b68eba84dd" args="" -->
typedef T&nbsp;</td><td class="memItemRight" valign="bottom"><b>ValueType</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9a10918529e7656aa003b12d05adcd19"></a><!-- doxytag: member="IECore::TypedData::BaseType" ref="a9a10918529e7656aa003b12d05adcd19" args="" -->
typedef <a class="el" href="classIECore_1_1TypedDataTraits.html">TypedDataTraits</a><br class="typebreak"/>
&lt; <a class="el" href="classIECore_1_1TypedData.html">TypedData</a>&lt; T &gt; &gt;::<a class="el" href="classIECore_1_1TypedData.html#a9a10918529e7656aa003b12d05adcd19">BaseType</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIECore_1_1TypedData.html#a9a10918529e7656aa003b12d05adcd19">BaseType</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Base type used in the internal data structure. <br/></td></tr>
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6d432b226681dae19562f896ad8f4e94"></a><!-- doxytag: member="IECore::TypedData::TypedData" ref="a6d432b226681dae19562f896ad8f4e94" args="()" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIECore_1_1TypedData.html#a6d432b226681dae19562f896ad8f4e94">TypedData</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default constructor. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a82041509fa7ce93f10f310377127e0ff"></a><!-- doxytag: member="IECore::TypedData::TypedData" ref="a82041509fa7ce93f10f310377127e0ff" args="(const T &amp;data)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIECore_1_1TypedData.html#a82041509fa7ce93f10f310377127e0ff">TypedData</a> (const T &amp;data)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor based on the stored data type. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a32851e698c1de1f20bb3a6486149daa0"></a><!-- doxytag: member="IECore::TypedData::IECORE_RUNTIMETYPED_DECLARETEMPLATE" ref="a32851e698c1de1f20bb3a6486149daa0" args="(TypedData&lt; T &gt;, Data)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><b>IECORE_RUNTIMETYPED_DECLARETEMPLATE</b> (<a class="el" href="classIECore_1_1TypedData.html">TypedData</a>&lt; T &gt;, <a class="el" href="classIECore_1_1Data.html">Data</a>)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad48ce5d95155e2b51aa0ce0a3293d693"></a><!-- doxytag: member="IECore::TypedData::operator=" ref="ad48ce5d95155e2b51aa0ce0a3293d693" args="(const T &amp;data)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIECore_1_1TypedData.html#ad48ce5d95155e2b51aa0ce0a3293d693">operator=</a> (const T &amp;data)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Equivalent to <a class="el" href="classIECore_1_1TypedData.html#a46e553cc78e51f5878e9a53976f3003c">writable()</a> = data. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a200399247e9553e4ed84074024f8545b"></a><!-- doxytag: member="IECore::TypedData::operator=" ref="a200399247e9553e4ed84074024f8545b" args="(const TypedData&lt; T &gt; &amp;typedData)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIECore_1_1TypedData.html#a200399247e9553e4ed84074024f8545b">operator=</a> (const <a class="el" href="classIECore_1_1TypedData.html">TypedData</a>&lt; T &gt; &amp;typedData)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Equivalent to <a class="el" href="classIECore_1_1TypedData.html#a46e553cc78e51f5878e9a53976f3003c">writable()</a> = typedData.readable(). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const T &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIECore_1_1TypedData.html#a7a431663150621efc8d30d22c289e8aa">readable</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">T &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIECore_1_1TypedData.html#a46e553cc78e51f5878e9a53976f3003c">writable</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classIECore_1_1TypedData.html#a9a10918529e7656aa003b12d05adcd19">BaseType</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIECore_1_1TypedData.html#a2734524913532951ed507e8364c1517e">baseReadable</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIECore_1_1TypedData.html#a9a10918529e7656aa003b12d05adcd19">BaseType</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIECore_1_1TypedData.html#aec17a269d0c476d610c439bd78d3c6c9">baseWritable</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIECore_1_1TypedData.html#a88f640294f2875b40c717c242e47fa7e">baseSize</a> () const </td></tr>
<tr><td colspan="2"><div class="groupHeader">Object interface</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrpa6e429251a8a18e64cdc2af4b8e3f86b"></a>///////////////////////////////////////////////////////// </p>
<br/><br/></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIECore_1_1TypedData.html">TypedData</a>&lt; T &gt;::Ptr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIECore_1_1TypedData.html#ab64ae1065db0a48ee2d37de82364d025">copy</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a16dc90276ab6615b412b9a80a56a0b13"></a><!-- doxytag: member="IECore::TypedData::isEqualTo" ref="a16dc90276ab6615b412b9a80a56a0b13" args="(const Object *other) const " -->
virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>isEqualTo</b> (const <a class="el" href="classIECore_1_1Object.html">Object</a> *other) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIECore_1_1TypedData.html#ae276b3b8ed9baf704c42e4b38297223b">hash</a> (<a class="el" href="classIECore_1_1MurmurHash.html">MurmurHash</a> &amp;h) const </td></tr>
<tr><td colspan="2"><h2>Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a372edf6962ecb7450d0dc23180fb3ff0"></a><!-- doxytag: member="IECore::TypedData::hasBase" ref="a372edf6962ecb7450d0dc23180fb3ff0" args="()" -->
static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIECore_1_1TypedData.html#a372edf6962ecb7450d0dc23180fb3ff0">hasBase</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Defines whether the internal data structure has a single base type. <br/></td></tr>
<tr><td colspan="2"><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a606bde803718973e9c986536f4e4d10a"></a><!-- doxytag: member="IECore::TypedData::copyFrom" ref="a606bde803718973e9c986536f4e4d10a" args="(const Object *other, CopyContext *context)" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>copyFrom</b> (const <a class="el" href="classIECore_1_1Object.html">Object</a> *other, <a class="el" href="classIECore_1_1Object_1_1CopyContext.html">CopyContext</a> *context)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIECore_1_1TypedData.html#a416d51eaeae85bb3e85cdc130cb053e4">save</a> (<a class="el" href="classIECore_1_1Object_1_1SaveContext.html">SaveContext</a> *context) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIECore_1_1TypedData.html#ad3aebc083803940b2bb27f72740946a5">load</a> (LoadContextPtr context)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIECore_1_1TypedData.html#a55d8a3ff4379130073e247dd43c1f47b">memoryUsage</a> (<a class="el" href="classIECore_1_1Object_1_1MemoryAccumulator.html">Object::MemoryAccumulator</a> &amp;accumulator) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abd361d9dad00f02c68d9602f3b78af6d"></a><!-- doxytag: member="IECore::TypedData::IE_CORE_DECLAREPTR" ref="abd361d9dad00f02c68d9602f3b78af6d" args="(DataHolder)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><b>IE_CORE_DECLAREPTR</b> (DataHolder)</td></tr>
<tr><td colspan="2"><h2>Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac7eb81808dcd05a40ec72fde482558ff"></a><!-- doxytag: member="IECore::TypedData::m_data" ref="ac7eb81808dcd05a40ec72fde482558ff" args="" -->
DataHolderPtr&nbsp;</td><td class="memItemRight" valign="bottom"><b>m_data</b></td></tr>
<tr><td colspan="2"><h2>Static Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa1a3820fc9e1addc9961b122f61327cc"></a><!-- doxytag: member="IECore::TypedData::m_typeDescription" ref="aa1a3820fc9e1addc9961b122f61327cc" args="" -->
static <a class="el" href="classIECore_1_1Object_1_1TypeDescription.html">Object::TypeDescription</a><br class="typebreak"/>
&lt; <a class="el" href="classIECore_1_1TypedData.html">TypedData</a>&lt; T &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>m_typeDescription</b></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;class T&gt;<br/>
 class IECore::TypedData&lt; T &gt;</h3>

<p>A templated class which can be used to wrap useful data types and containers. The copyFrom() function is implemented so as to perform a lazy copy on write type behaviour - this makes the creation of read only copies of significant amounts of data relatively cheap. Note that as this class derives from <a class="el" href="classIECore_1_1Object.html">Object</a>, a proper instantiation requires a fair bit of specialisation of the methods reimplemented from <a class="el" href="classIECore_1_1Object.html">Object</a>. For this reason the template implementation is hidden from the public interface, and you can therefore only use only the typedefs in <a class="el" href="SimpleTypedData_8h_source.html">SimpleTypedData.h</a>, <a class="el" href="VectorTypedData_8h_source.html">VectorTypedData.h</a> and <a class="el" href="CompoundData_8h_source.html">CompoundData.h</a> rather than being able to instantiate the template for arbitrary data types. It also provides low level access to its data through functions like baseReadable, baseWritable and baseSize. They are available only when the data can be seen as an array of a base type. Use hasBase for checking that. </p>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a2734524913532951ed507e8364c1517e"></a><!-- doxytag: member="IECore::TypedData::baseReadable" ref="a2734524913532951ed507e8364c1517e" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classIECore_1_1TypedData.html#a9a10918529e7656aa003b12d05adcd19">BaseType</a>* <a class="el" href="classIECore_1_1TypedData.html">IECore::TypedData</a>&lt; T &gt;::baseReadable </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get low level read-only access to the internal data structure as a reference to the first element on an array of base type. Throws an <a class="el" href="classIECore_1_1Exception.html">Exception</a> if this type has no single base type. </p>

</div>
</div>
<a class="anchor" id="a88f640294f2875b40c717c242e47fa7e"></a><!-- doxytag: member="IECore::TypedData::baseSize" ref="a88f640294f2875b40c717c242e47fa7e" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classIECore_1_1TypedData.html">IECore::TypedData</a>&lt; T &gt;::baseSize </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the size of the internal data structure in terms of base type elements. Throws an <a class="el" href="classIECore_1_1Exception.html">Exception</a> if this type has no single base type. </p>

</div>
</div>
<a class="anchor" id="aec17a269d0c476d610c439bd78d3c6c9"></a><!-- doxytag: member="IECore::TypedData::baseWritable" ref="aec17a269d0c476d610c439bd78d3c6c9" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIECore_1_1TypedData.html#a9a10918529e7656aa003b12d05adcd19">BaseType</a>* <a class="el" href="classIECore_1_1TypedData.html">IECore::TypedData</a>&lt; T &gt;::baseWritable </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get low level read-write access to the internal data structure as a reference to the first element on an array of base type. Throws an <a class="el" href="classIECore_1_1Exception.html">Exception</a> if this type has no single base type. </p>

</div>
</div>
<a class="anchor" id="ab64ae1065db0a48ee2d37de82364d025"></a><!-- doxytag: member="IECore::TypedData::copy" ref="ab64ae1065db0a48ee2d37de82364d025" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIECore_1_1TypedData.html">TypedData</a>&lt;T&gt;::Ptr <a class="el" href="classIECore_1_1TypedData.html">IECore::TypedData</a>&lt; T &gt;::copy </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns a deep copy of this object. In subclasses an identical function is provided which returns a pointer to the subclass rather than to this base class. </p>

<p>Reimplemented from <a class="el" href="classIECore_1_1Object.html#a7058d48a8950ae269c2bb1a1aa3a572c">IECore::Object</a>.</p>

</div>
</div>
<a class="anchor" id="ae276b3b8ed9baf704c42e4b38297223b"></a><!-- doxytag: member="IECore::TypedData::hash" ref="ae276b3b8ed9baf704c42e4b38297223b" args="(MurmurHash &amp;h) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classIECore_1_1TypedData.html">IECore::TypedData</a>&lt; T &gt;::hash </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classIECore_1_1MurmurHash.html">MurmurHash</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>h</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Must be implemented by subclasses to append all member data into the given hash. Implementations must first call the base class implementation before appending their own data. </p>

<p>Implements <a class="el" href="classIECore_1_1Object.html#a10e1640a0d6e42aae91d9453a7e7a749">IECore::Object</a>.</p>

</div>
</div>
<a class="anchor" id="ad3aebc083803940b2bb27f72740946a5"></a><!-- doxytag: member="IECore::TypedData::load" ref="ad3aebc083803940b2bb27f72740946a5" args="(LoadContextPtr context)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classIECore_1_1TypedData.html">IECore::TypedData</a>&lt; T &gt;::load </td>
          <td>(</td>
          <td class="paramtype">LoadContextPtr&nbsp;</td>
          <td class="paramname"> <em>context</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Must be implemented in all derived classes. Implementations should first call the parent class <a class="el" href="classIECore_1_1TypedData.html#ad3aebc083803940b2bb27f72740946a5">load()</a> method, then call context-&gt;container() before loading their member data from that container. context is a smart pointer to a reference counted object to allow you to keep the context and perform lazy loading at a later date - although this is not yet used by any of the core types. A call to context-&gt;container() will throw an <a class="el" href="classIECore_1_1Exception.html">Exception</a> if the corresponding <a class="el" href="classIECore_1_1TypedData.html#a416d51eaeae85bb3e85cdc130cb053e4">save()</a> method did not create a container. </p>

<p>Implements <a class="el" href="classIECore_1_1Object.html#a3f4b7b9cbe56579d9c90bfb9539470ef">IECore::Object</a>.</p>

</div>
</div>
<a class="anchor" id="a55d8a3ff4379130073e247dd43c1f47b"></a><!-- doxytag: member="IECore::TypedData::memoryUsage" ref="a55d8a3ff4379130073e247dd43c1f47b" args="(Object::MemoryAccumulator &amp;accumulator) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classIECore_1_1TypedData.html">IECore::TypedData</a>&lt; T &gt;::memoryUsage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classIECore_1_1Object_1_1MemoryAccumulator.html">Object::MemoryAccumulator</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>accumulator</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>If the memory usage is anything other than sizeof(T) for a given T then you must provide an accurate specialisation for this function. </p>

<p>Implements <a class="el" href="classIECore_1_1Object.html#a31a7101725bbf84b2a39099ad9c5a7a2">IECore::Object</a>.</p>

</div>
</div>
<a class="anchor" id="a7a431663150621efc8d30d22c289e8aa"></a><!-- doxytag: member="IECore::TypedData::readable" ref="a7a431663150621efc8d30d22c289e8aa" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; <a class="el" href="classIECore_1_1TypedData.html">IECore::TypedData</a>&lt; T &gt;::readable </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Gives read-only access to the internal data structure. </p>
<dl class="user"><dt><b>Threading:</b></dt><dd>It's safe for multiple concurrent threads to call <a class="el" href="classIECore_1_1TypedData.html#a7a431663150621efc8d30d22c289e8aa">readable()</a> on the same instance, provided that no concurrent modifications are being made to that instance. </dd></dl>

</div>
</div>
<a class="anchor" id="a416d51eaeae85bb3e85cdc130cb053e4"></a><!-- doxytag: member="IECore::TypedData::save" ref="a416d51eaeae85bb3e85cdc130cb053e4" args="(SaveContext *context) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classIECore_1_1TypedData.html">IECore::TypedData</a>&lt; T &gt;::save </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classIECore_1_1Object_1_1SaveContext.html">SaveContext</a> *&nbsp;</td>
          <td class="paramname"> <em>context</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Must be implemented in all derived classes. Implementations should first call the parent class <a class="el" href="classIECore_1_1TypedData.html#a416d51eaeae85bb3e85cdc130cb053e4">save()</a> method, then call context-&gt;container() before filling the returned container with their member data. Classes with no member data may omit the call to container(), resulting in smaller file sizes. </p>

<p>Implements <a class="el" href="classIECore_1_1Object.html#a9b46077c8db3d50975e124131e52c32f">IECore::Object</a>.</p>

</div>
</div>
<a class="anchor" id="a46e553cc78e51f5878e9a53976f3003c"></a><!-- doxytag: member="IECore::TypedData::writable" ref="a46e553cc78e51f5878e9a53976f3003c" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T&amp; <a class="el" href="classIECore_1_1TypedData.html">IECore::TypedData</a>&lt; T &gt;::writable </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Gives read-write access to the internal data structure. </p>
<dl class="user"><dt><b>Threading:</b></dt><dd>Because calling <a class="el" href="classIECore_1_1TypedData.html#a46e553cc78e51f5878e9a53976f3003c">writable()</a> may cause data to be copied behind the scenes, it may not be called while other threads are operating on the same instance. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/IECore/<a class="el" href="TypedData_8h_source.html">TypedData.h</a></li>
</ul>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&nbsp;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&nbsp;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&nbsp;</span>Friends</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr size="1"/><address style="text-align: right;"><small>Generated on 5 Jan 2012 for Cortex by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
