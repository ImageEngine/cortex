<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Cortex: IECore::Object Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.6.1 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<script type="text/javascript">
<!--
function changeDisplayState (e){
  var num=this.id.replace(/[^[0-9]/g,'');
  var button=this.firstChild;
  var sectionDiv=document.getElementById('dynsection'+num);
  if (sectionDiv.style.display=='none'||sectionDiv.style.display==''){
    sectionDiv.style.display='block';
    button.src='open.gif';
  }else{
    sectionDiv.style.display='none';
    button.src='closed.gif';
  }
}
function initDynSections(){
  var divs=document.getElementsByTagName('div');
  var sectionCounter=1;
  for(var i=0;i<divs.length-1;i++){
    if(divs[i].className=='dynheader'&&divs[i+1].className=='dynsection'){
      var header=divs[i];
      var section=divs[i+1];
      var button=header.firstChild;
      if (button!='IMG'){
        divs[i].insertBefore(document.createTextNode(' '),divs[i].firstChild);
        button=document.createElement('img');
        divs[i].insertBefore(button,divs[i].firstChild);
      }
      header.style.cursor='pointer';
      header.onclick=changeDisplayState;
      header.id='dynheader'+sectionCounter;
      button.src='closed.gif';
      section.id='dynsection'+sectionCounter;
      section.style.display='none';
      section.style.marginLeft='14px';
      sectionCounter++;
    }
  }
}
window.onload = initDynSections;
-->
</script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <img id="MSearchSelect" src="search/search.png"
             onmouseover="return searchBox.OnSearchSelectShow()"
             onmouseout="return searchBox.OnSearchSelectHide()"
             alt=""/>
        <input type="text" id="MSearchField" value="Search" accesskey="S"
             onfocus="searchBox.OnSearchFieldFocus(true)" 
             onblur="searchBox.OnSearchFieldFocus(false)" 
             onkeyup="searchBox.OnSearchFieldChange(event)"/>
        <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
        </div>
      </li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="namespaceIECore.html">IECore</a>::<a class="el" href="classIECore_1_1Object.html">Object</a>
  </div>
</div>
<div class="contents">
<h1>IECore::Object Class Reference<br/>
<small>
[<a class="el" href="group__coreGroup.html">Core</a>]</small>
</h1><!-- doxytag: class="IECore::Object" --><!-- doxytag: inherits="IECore::RunTimeTyped" -->
<p><code>#include &lt;<a class="el" href="Object_8h_source.html">Object.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for IECore::Object:</div>
<div class="dynsection">
 <div class="center">
  <img src="classIECore_1_1Object.gif" usemap="#IECore::Object_map" alt=""/>
  <map id="IECore::Object_map" name="IECore::Object_map">
<area href="classIECore_1_1RunTimeTyped.html" alt="IECore::RunTimeTyped" shape="rect" coords="1315,56,1568,80"/>
<area href="classIECore_1_1RefCounted.html" alt="IECore::RefCounted" shape="rect" coords="1315,0,1568,24"/>
<area href="classIECore_1_1BlindDataHolder.html" alt="IECore::BlindDataHolder" shape="rect" coords="263,168,516,192"/>
<area href="classIECore_1_1CompoundObject.html" alt="IECore::CompoundObject" shape="rect" coords="526,168,779,192"/>
<area href="classIECore_1_1Data.html" alt="IECore::Data" shape="rect" coords="1315,168,1568,192"/>
<area href="classIECore_1_1NullObject.html" alt="IECore::NullObject" shape="rect" coords="1578,168,1831,192"/>
<area href="classIECore_1_1ObjectVector.html" alt="IECore::ObjectVector" shape="rect" coords="1841,168,2094,192"/>
<area href="classIECore_1_1Renderable.html" alt="IECore::Renderable" shape="rect" coords="263,224,516,248"/>
<area href="classIECore_1_1SmoothSkinningData.html" alt="IECore::SmoothSkinningData" shape="rect" coords="526,224,779,248"/>
<area href="classIECore_1_1TypedData.html" alt="IECore::TypedData&lt; T &gt;" shape="rect" coords="1052,224,1305,248"/>
<area href="classIECore_1_1TypedData.html" alt="IECore::TypedData&lt; CompoundDataMap &gt;" shape="rect" coords="1315,224,1568,248"/>
<area href="classIECore_1_1TypedData.html" alt="IECore::TypedData&lt; int &gt;" shape="rect" coords="1578,224,1831,248"/>
<area href="classIECore_1_1TypedData.html" alt="IECore::TypedData&lt; int &gt; &gt;" shape="rect" coords="1841,224,2094,248"/>
<area href="classIECore_1_1PreWorldRenderable.html" alt="IECore::PreWorldRenderable" shape="rect" coords="0,280,253,304"/>
<area href="classIECore_1_1StateRenderable.html" alt="IECore::StateRenderable" shape="rect" coords="263,280,516,304"/>
<area href="classIECore_1_1VisibleRenderable.html" alt="IECore::VisibleRenderable" shape="rect" coords="789,280,1042,304"/>
<area href="classIECore_1_1LongVectorDataAlias.html" alt="IECore::LongVectorDataAlias" shape="rect" coords="1052,280,1305,304"/>
<area href="classIECore_1_1CompoundData.html" alt="IECore::CompoundData" shape="rect" coords="1315,280,1568,304"/>
<area href="classIECore_1_1LongDataAlias.html" alt="IECore::LongDataAlias" shape="rect" coords="1578,280,1831,304"/>
<area href="classIECore_1_1Display.html" alt="IECore::Display" shape="rect" coords="0,336,253,360"/>
<area href="classIECore_1_1AttributeState.html" alt="IECore::AttributeState" shape="rect" coords="526,336,779,360"/>
<area href="classIECore_1_1Light.html" alt="IECore::Light" shape="rect" coords="526,392,779,416"/>
<area href="classIECore_1_1Shader.html" alt="IECore::Shader" shape="rect" coords="526,448,779,472"/>
<area href="classIECore_1_1Transform.html" alt="IECore::Transform" shape="rect" coords="526,504,779,528"/>
<area href="classIECore_1_1Group.html" alt="IECore::Group" shape="rect" coords="1052,336,1305,360"/>
<area href="classIECore_1_1MotionPrimitive.html" alt="IECore::MotionPrimitive" shape="rect" coords="1052,392,1305,416"/>
<area href="classIECore_1_1ParameterisedProcedural.html" alt="IECore::ParameterisedProcedural" shape="rect" coords="1052,448,1305,472"/>
<area href="classIECore_1_1Primitive.html" alt="IECore::Primitive" shape="rect" coords="1052,504,1305,528"/>
</map>
 </div>
</div>

<p><a href="classIECore_1_1Object-members.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIECore_1_1Object_1_1AbstractTypeDescription.html">AbstractTypeDescription</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIECore_1_1Object_1_1CopyContext.html">CopyContext</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIECore_1_1Object_1_1LoadContext.html">LoadContext</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The class provided to the <a class="el" href="classIECore_1_1Object_1_1LoadContext.html#aa95807ced5c1d47e9f83e49358485e07" title="Load an Object instance previously saved by SaveContext::save().">load()</a> method implemented by subclasses.  <a href="classIECore_1_1Object_1_1LoadContext.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIECore_1_1Object_1_1MemoryAccumulator.html">MemoryAccumulator</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIECore_1_1Object_1_1SaveContext.html">SaveContext</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The class provided to the <a class="el" href="classIECore_1_1Object_1_1SaveContext.html#a4ab64c1725b2ffd0905be2acf699001b">save()</a> method implemented by subclasses.  <a href="classIECore_1_1Object_1_1SaveContext.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIECore_1_1Object_1_1TypeDescription.html">TypeDescription</a></td></tr>
<tr><td colspan="2"><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3a20a70523255cd15bd590febdbf232d"></a><!-- doxytag: member="IECore::Object::CreatorFn" ref="a3a20a70523255cd15bd590febdbf232d" args=")(void *data)" -->
typedef ObjectPtr(*&nbsp;</td><td class="memItemRight" valign="bottom"><b>CreatorFn</b> )(void *data)</td></tr>
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a36a208917254e1d2a3400197c5ead7c8"></a><!-- doxytag: member="IECore::Object::IE_CORE_DECLARERUNTIMETYPED" ref="a36a208917254e1d2a3400197c5ead7c8" args="(Object, RunTimeTyped)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><b>IE_CORE_DECLARERUNTIMETYPED</b> (<a class="el" href="classIECore_1_1Object.html">Object</a>, <a class="el" href="classIECore_1_1RunTimeTyped.html">RunTimeTyped</a>)</td></tr>
<tr><td colspan="2"><div class="groupHeader">Object interface</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrpa6e429251a8a18e64cdc2af4b8e3f86b"></a> The following functions define the interface to which all <a class="el" href="classIECore_1_1Object.html">Object</a> subclasses must adhere. Note that the IE_CORE_DECLAREOBJECT macro is provided to simplify the declaration of these functions for your own derived classes. Note also that there is additional protected interface which you must implement - this too is declared (but not implemented) by the IE_CORE_DECLAREOBJECT macro. </p>
<br/><br/></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ObjectPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIECore_1_1Object.html#a7058d48a8950ae269c2bb1a1aa3a572c">copy</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIECore_1_1Object.html#aed4cbf2dd99c12360209d8f0718a46d7">copyFrom</a> (const <a class="el" href="classIECore_1_1Object.html">Object</a> *other)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIECore_1_1Object.html#a3263c27cd23544d3ee7c341e3e9f5265">save</a> (IndexedIOInterfacePtr ioInterface, const IndexedIO::EntryID &amp;name) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIECore_1_1Object.html#ac5691667d5906ef7d97c0ab1136489b6">isEqualTo</a> (const <a class="el" href="classIECore_1_1Object.html">Object</a> *other) const =0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIECore_1_1Object.html#a6ed85fadcdab994d9d8bd36e92afa177">isNotEqualTo</a> (const <a class="el" href="classIECore_1_1Object.html">Object</a> *other) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8b086fedd790fc762d9120a33cb016c6"></a><!-- doxytag: member="IECore::Object::operator==" ref="a8b086fedd790fc762d9120a33cb016c6" args="(const Object &amp;other) const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIECore_1_1Object.html#a8b086fedd790fc762d9120a33cb016c6">operator==</a> (const <a class="el" href="classIECore_1_1Object.html">Object</a> &amp;other) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calls <a class="el" href="classIECore_1_1Object.html#ac5691667d5906ef7d97c0ab1136489b6">isEqualTo()</a> for people who prefer to use the operator syntax. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a21d471bce4e46a5db1cc7892d44a52c8"></a><!-- doxytag: member="IECore::Object::operator!=" ref="a21d471bce4e46a5db1cc7892d44a52c8" args="(const Object &amp;other) const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIECore_1_1Object.html#a21d471bce4e46a5db1cc7892d44a52c8">operator!=</a> (const <a class="el" href="classIECore_1_1Object.html">Object</a> &amp;other) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calls <a class="el" href="classIECore_1_1Object.html#a6ed85fadcdab994d9d8bd36e92afa177">isNotEqualTo()</a> for people who prefer to use the operator syntax. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac6e89b273cf3382c994b8d60115c8127"></a><!-- doxytag: member="IECore::Object::memoryUsage" ref="ac6e89b273cf3382c994b8d60115c8127" args="() const " -->
size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIECore_1_1Object.html#ac6e89b273cf3382c994b8d60115c8127">memoryUsage</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the number of bytes this instance occupies in memory. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIECore_1_1MurmurHash.html">MurmurHash</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIECore_1_1Object.html#a28c0da9e4591e48de36ca439ce2a6a2a">hash</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIECore_1_1Object.html#a10e1640a0d6e42aae91d9453a7e7a749">hash</a> (<a class="el" href="classIECore_1_1MurmurHash.html">MurmurHash</a> &amp;h) const =0</td></tr>
<tr><td colspan="2"><h2>Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a55886d9f20f707a4a2ac6ab92b935a58"></a><!-- doxytag: member="IECore::Object::registerType" ref="a55886d9f20f707a4a2ac6ab92b935a58" args="(TypeId typeId, const std::string &amp;typeName, CreatorFn creator, void *data=0)" -->
static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIECore_1_1Object.html#a55886d9f20f707a4a2ac6ab92b935a58">registerType</a> (<a class="el" href="namespaceIECore.html#af294ec67f3b39230d75efef3844cf448">TypeId</a> typeId, const std::string &amp;typeName, CreatorFn creator, void *data=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Register a new Object-derived type with the system. The specified void* data is passed into the creator function. <br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Object factory</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrpf3048c64e1fb15ed758878c1db460b82"></a> The following static functions provide the ability to create an <a class="el" href="classIECore_1_1Object.html">Object</a> of a given type or typeId, as well as providing conversions between type names and TypeIds. </p>
<br/><br/></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae79a8f1020677cab16b83e3fa84ee677"></a><!-- doxytag: member="IECore::Object::isType" ref="ae79a8f1020677cab16b83e3fa84ee677" args="(TypeId typeId)" -->
static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIECore_1_1Object.html#ae79a8f1020677cab16b83e3fa84ee677">isType</a> (<a class="el" href="namespaceIECore.html#af294ec67f3b39230d75efef3844cf448">TypeId</a> typeId)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns true if typeId is a valid registered <a class="el" href="classIECore_1_1Object.html">Object</a> type. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a95b7106b83c2e3b25d789f54a4f5fbbe"></a><!-- doxytag: member="IECore::Object::isType" ref="a95b7106b83c2e3b25d789f54a4f5fbbe" args="(const std::string &amp;typeName)" -->
static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIECore_1_1Object.html#a95b7106b83c2e3b25d789f54a4f5fbbe">isType</a> (const std::string &amp;typeName)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns true if typeName is a valid registered <a class="el" href="classIECore_1_1Object.html">Object</a> type. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIECore_1_1Object.html#a2305005ed20eda5a7922cf6290cfa193">isAbstractType</a> (<a class="el" href="namespaceIECore.html#af294ec67f3b39230d75efef3844cf448">TypeId</a> typeId)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a32b7b832d2fe4f1f2cae4d11ae3be4fa"></a><!-- doxytag: member="IECore::Object::isAbstractType" ref="a32b7b832d2fe4f1f2cae4d11ae3be4fa" args="(const std::string &amp;typeName)" -->
static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIECore_1_1Object.html#a32b7b832d2fe4f1f2cae4d11ae3be4fa">isAbstractType</a> (const std::string &amp;typeName)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">As above but taking a type name. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static ObjectPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIECore_1_1Object.html#a7292f57ede3762f6fb64365242801a3c">create</a> (<a class="el" href="namespaceIECore.html#af294ec67f3b39230d75efef3844cf448">TypeId</a> typeId)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static ObjectPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIECore_1_1Object.html#ada37c085cf2a19eea2744f52ef74bc5f">create</a> (const std::string &amp;typeName)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static ObjectPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIECore_1_1Object.html#ad63937970487a90681d6a41e77e4657b">load</a> (IndexedIOInterfacePtr ioInterface, const IndexedIO::EntryID &amp;name)</td></tr>
<tr><td colspan="2"><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIECore_1_1Object.html#a5b827d672454436e354e67c77cb48b13">copyFrom</a> (const <a class="el" href="classIECore_1_1Object.html">Object</a> *other, <a class="el" href="classIECore_1_1Object_1_1CopyContext.html">CopyContext</a> *context)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a46a67526af37b83ac470ac8fa0f0d513"></a><!-- doxytag: member="IECore::Object::IE_CORE_DECLAREPTR" ref="a46a67526af37b83ac470ac8fa0f0d513" args="(LoadContext)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><b>IE_CORE_DECLAREPTR</b> (<a class="el" href="classIECore_1_1Object_1_1LoadContext.html">LoadContext</a>)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIECore_1_1Object.html#a9b46077c8db3d50975e124131e52c32f">save</a> (<a class="el" href="classIECore_1_1Object_1_1SaveContext.html">SaveContext</a> *context) const =0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIECore_1_1Object.html#a3f4b7b9cbe56579d9c90bfb9539470ef">load</a> (LoadContextPtr context)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIECore_1_1Object.html#a31a7101725bbf84b2a39099ad9c5a7a2">memoryUsage</a> (<a class="el" href="classIECore_1_1Object_1_1MemoryAccumulator.html">MemoryAccumulator</a> &amp;accumulator) const =0</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>A base class defining copying and streaming. </p>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a7058d48a8950ae269c2bb1a1aa3a572c"></a><!-- doxytag: member="IECore::Object::copy" ref="a7058d48a8950ae269c2bb1a1aa3a572c" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ObjectPtr IECore::Object::copy </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns a deep copy of this object. In subclasses an identical function is provided which returns a pointer to the subclass rather than to this base class. </p>

<p>Reimplemented in <a class="el" href="classIECore_1_1TypedData.html#ab64ae1065db0a48ee2d37de82364d025">IECore::TypedData&lt; T &gt;</a>, <a class="el" href="classIECore_1_1TypedData.html#ab64ae1065db0a48ee2d37de82364d025">IECore::TypedData&lt; CompoundDataMap &gt;</a>, <a class="el" href="classIECore_1_1TypedData.html#ab64ae1065db0a48ee2d37de82364d025">IECore::TypedData&lt; int &gt;</a>, <a class="el" href="classIECore_1_1TypedData.html#ab64ae1065db0a48ee2d37de82364d025">IECore::TypedData&lt; std::vector&lt; T &gt; &gt;</a>, <a class="el" href="classIECore_1_1TypedData.html#ab64ae1065db0a48ee2d37de82364d025">IECore::TypedData&lt; int &gt; &gt;</a>, and <a class="el" href="classIECore_1_1TypedData.html#ab64ae1065db0a48ee2d37de82364d025">IECore::TypedData&lt; std::vector&lt; Imath::Vec3&lt; PointBaseType &gt; &gt; &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a5b827d672454436e354e67c77cb48b13"></a><!-- doxytag: member="IECore::Object::copyFrom" ref="a5b827d672454436e354e67c77cb48b13" args="(const Object *other, CopyContext *context)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void IECore::Object::copyFrom </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIECore_1_1Object.html">Object</a> *&nbsp;</td>
          <td class="paramname"> <em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classIECore_1_1Object_1_1CopyContext.html">CopyContext</a> *&nbsp;</td>
          <td class="paramname"> <em>context</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected, pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Must be implemented in all subclasses to make a deep copy of all member data, after calling BaseClass::copyFrom() to allow the base class to do the same. When making copies of held member data derived from <a class="el" href="classIECore_1_1Object.html">Object</a>, you /must/ use the context object provided, rather than calling <a class="el" href="classIECore_1_1Object.html#a7058d48a8950ae269c2bb1a1aa3a572c">copy()</a> or <a class="el" href="classIECore_1_1Object.html#aed4cbf2dd99c12360209d8f0718a46d7">copyFrom()</a> yourself. </p>

</div>
</div>
<a class="anchor" id="aed4cbf2dd99c12360209d8f0718a46d7"></a><!-- doxytag: member="IECore::Object::copyFrom" ref="aed4cbf2dd99c12360209d8f0718a46d7" args="(const Object *other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IECore::Object::copyFrom </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIECore_1_1Object.html">Object</a> *&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Copies from another object. Throws an <a class="el" href="classIECore_1_1InvalidArgumentException.html" title="Base class for Invalid Argument exceptions.">IECore::InvalidArgumentException</a> if other is not an instance of this object. </p>

</div>
</div>
<a class="anchor" id="ada37c085cf2a19eea2744f52ef74bc5f"></a><!-- doxytag: member="IECore::Object::create" ref="ada37c085cf2a19eea2744f52ef74bc5f" args="(const std::string &amp;typeName)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static ObjectPtr IECore::Object::create </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>typeName</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Creates an instance of an object of the specified type. Throws an <a class="el" href="classIECore_1_1Exception.html">Exception</a> if typeName is not a valid type. </p>

</div>
</div>
<a class="anchor" id="a7292f57ede3762f6fb64365242801a3c"></a><!-- doxytag: member="IECore::Object::create" ref="a7292f57ede3762f6fb64365242801a3c" args="(TypeId typeId)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static ObjectPtr IECore::Object::create </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceIECore.html#af294ec67f3b39230d75efef3844cf448">TypeId</a>&nbsp;</td>
          <td class="paramname"> <em>typeId</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Creates an instance of an object of the specified type. Throws an <a class="el" href="classIECore_1_1Exception.html">Exception</a> if typeId is not a valid type. </p>

</div>
</div>
<a class="anchor" id="a10e1640a0d6e42aae91d9453a7e7a749"></a><!-- doxytag: member="IECore::Object::hash" ref="a10e1640a0d6e42aae91d9453a7e7a749" args="(MurmurHash &amp;h) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void IECore::Object::hash </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classIECore_1_1MurmurHash.html">MurmurHash</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>h</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Must be implemented by subclasses to append all member data into the given hash. Implementations must first call the base class implementation before appending their own data. </p>

<p>Implemented in <a class="el" href="classIECore_1_1TypedData.html#ae276b3b8ed9baf704c42e4b38297223b">IECore::TypedData&lt; T &gt;</a>, <a class="el" href="classIECore_1_1TypedData.html#ae276b3b8ed9baf704c42e4b38297223b">IECore::TypedData&lt; CompoundDataMap &gt;</a>, <a class="el" href="classIECore_1_1TypedData.html#ae276b3b8ed9baf704c42e4b38297223b">IECore::TypedData&lt; int &gt;</a>, <a class="el" href="classIECore_1_1TypedData.html#ae276b3b8ed9baf704c42e4b38297223b">IECore::TypedData&lt; std::vector&lt; T &gt; &gt;</a>, <a class="el" href="classIECore_1_1TypedData.html#ae276b3b8ed9baf704c42e4b38297223b">IECore::TypedData&lt; int &gt; &gt;</a>, and <a class="el" href="classIECore_1_1TypedData.html#ae276b3b8ed9baf704c42e4b38297223b">IECore::TypedData&lt; std::vector&lt; Imath::Vec3&lt; PointBaseType &gt; &gt; &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a28c0da9e4591e48de36ca439ce2a6a2a"></a><!-- doxytag: member="IECore::Object::hash" ref="a28c0da9e4591e48de36ca439ce2a6a2a" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIECore_1_1MurmurHash.html">MurmurHash</a> IECore::Object::hash </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns a hash computed from all the member data of this object. This convenience function simply creates a <a class="el" href="classIECore_1_1MurmurHash.html">MurmurHash</a> object, appends to it using the virtual function below and then returns it. </p>

</div>
</div>
<a class="anchor" id="a2305005ed20eda5a7922cf6290cfa193"></a><!-- doxytag: member="IECore::Object::isAbstractType" ref="a2305005ed20eda5a7922cf6290cfa193" args="(TypeId typeId)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bool IECore::Object::isAbstractType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceIECore.html#af294ec67f3b39230d75efef3844cf448">TypeId</a>&nbsp;</td>
          <td class="paramname"> <em>typeId</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns true if typeId is a valid registered abstract <a class="el" href="classIECore_1_1Object.html">Object</a> type - one which cannot be instantiated with <a class="el" href="classIECore_1_1Object.html#a7292f57ede3762f6fb64365242801a3c">create()</a>. </p>

</div>
</div>
<a class="anchor" id="ac5691667d5906ef7d97c0ab1136489b6"></a><!-- doxytag: member="IECore::Object::isEqualTo" ref="ac5691667d5906ef7d97c0ab1136489b6" args="(const Object *other) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool IECore::Object::isEqualTo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIECore_1_1Object.html">Object</a> *&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns true if this object is equal to the other. Should be reimplemented appropriately in derived classes, first calling your base class <a class="el" href="classIECore_1_1Object.html#ac5691667d5906ef7d97c0ab1136489b6">isEqualTo()</a> and returning false straight away if that returns false. The <a class="el" href="classIECore_1_1Object.html">Object</a> level implementation checks that the types are identical, so you can safely perform a staticPointerCast&lt;YourClass&gt;( other ) if your base class <a class="el" href="classIECore_1_1Object.html#ac5691667d5906ef7d97c0ab1136489b6">isEqualTo()</a> doesn't return false. </p>

</div>
</div>
<a class="anchor" id="a6ed85fadcdab994d9d8bd36e92afa177"></a><!-- doxytag: member="IECore::Object::isNotEqualTo" ref="a6ed85fadcdab994d9d8bd36e92afa177" args="(const Object *other) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool IECore::Object::isNotEqualTo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIECore_1_1Object.html">Object</a> *&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns true if this object is not equal to the other. A default implementation for this returns the negation of <a class="el" href="classIECore_1_1Object.html#ac5691667d5906ef7d97c0ab1136489b6">isEqualTo()</a>, but you may wish to override it if you can provide a faster implementation for a specific subclass. </p>

</div>
</div>
<a class="anchor" id="a3f4b7b9cbe56579d9c90bfb9539470ef"></a><!-- doxytag: member="IECore::Object::load" ref="a3f4b7b9cbe56579d9c90bfb9539470ef" args="(LoadContextPtr context)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void IECore::Object::load </td>
          <td>(</td>
          <td class="paramtype">LoadContextPtr&nbsp;</td>
          <td class="paramname"> <em>context</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected, pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Must be implemented in all derived classes. Implementations should first call the parent class <a class="el" href="classIECore_1_1Object.html#ad63937970487a90681d6a41e77e4657b">load()</a> method, then call context-&gt;container() before loading their member data from that container. context is a smart pointer to a reference counted object to allow you to keep the context and perform lazy loading at a later date - although this is not yet used by any of the core types. A call to context-&gt;container() will throw an <a class="el" href="classIECore_1_1Exception.html">Exception</a> if the corresponding <a class="el" href="classIECore_1_1Object.html#a3263c27cd23544d3ee7c341e3e9f5265">save()</a> method did not create a container. </p>

<p>Implemented in <a class="el" href="classIECore_1_1TypedData.html#ad3aebc083803940b2bb27f72740946a5">IECore::TypedData&lt; T &gt;</a>, <a class="el" href="classIECore_1_1TypedData.html#ad3aebc083803940b2bb27f72740946a5">IECore::TypedData&lt; CompoundDataMap &gt;</a>, <a class="el" href="classIECore_1_1TypedData.html#ad3aebc083803940b2bb27f72740946a5">IECore::TypedData&lt; int &gt;</a>, <a class="el" href="classIECore_1_1TypedData.html#ad3aebc083803940b2bb27f72740946a5">IECore::TypedData&lt; std::vector&lt; T &gt; &gt;</a>, <a class="el" href="classIECore_1_1TypedData.html#ad3aebc083803940b2bb27f72740946a5">IECore::TypedData&lt; int &gt; &gt;</a>, and <a class="el" href="classIECore_1_1TypedData.html#ad3aebc083803940b2bb27f72740946a5">IECore::TypedData&lt; std::vector&lt; Imath::Vec3&lt; PointBaseType &gt; &gt; &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="ad63937970487a90681d6a41e77e4657b"></a><!-- doxytag: member="IECore::Object::load" ref="ad63937970487a90681d6a41e77e4657b" args="(IndexedIOInterfacePtr ioInterface, const IndexedIO::EntryID &amp;name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static ObjectPtr IECore::Object::load </td>
          <td>(</td>
          <td class="paramtype">IndexedIOInterfacePtr&nbsp;</td>
          <td class="paramname"> <em>ioInterface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IndexedIO::EntryID &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Loads an object previously saved with the given name in the current directory of ioInterface. </p>

</div>
</div>
<a class="anchor" id="a31a7101725bbf84b2a39099ad9c5a7a2"></a><!-- doxytag: member="IECore::Object::memoryUsage" ref="a31a7101725bbf84b2a39099ad9c5a7a2" args="(MemoryAccumulator &amp;accumulator) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void IECore::Object::memoryUsage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classIECore_1_1Object_1_1MemoryAccumulator.html">MemoryAccumulator</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>accumulator</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [protected, pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Must be implemented in all derived classes to specify the amount of memory they are using. An implementation must add it's memory usage to the accumulator before calling <a class="el" href="classIECore_1_1Object.html#ac6e89b273cf3382c994b8d60115c8127" title="Returns the number of bytes this instance occupies in memory.">memoryUsage()</a> on its base class. </p>

<p>Implemented in <a class="el" href="classIECore_1_1TypedData.html#a55d8a3ff4379130073e247dd43c1f47b">IECore::TypedData&lt; T &gt;</a>, <a class="el" href="classIECore_1_1TypedData.html#a55d8a3ff4379130073e247dd43c1f47b">IECore::TypedData&lt; CompoundDataMap &gt;</a>, <a class="el" href="classIECore_1_1TypedData.html#a55d8a3ff4379130073e247dd43c1f47b">IECore::TypedData&lt; int &gt;</a>, <a class="el" href="classIECore_1_1TypedData.html#a55d8a3ff4379130073e247dd43c1f47b">IECore::TypedData&lt; std::vector&lt; T &gt; &gt;</a>, <a class="el" href="classIECore_1_1TypedData.html#a55d8a3ff4379130073e247dd43c1f47b">IECore::TypedData&lt; int &gt; &gt;</a>, and <a class="el" href="classIECore_1_1TypedData.html#a55d8a3ff4379130073e247dd43c1f47b">IECore::TypedData&lt; std::vector&lt; Imath::Vec3&lt; PointBaseType &gt; &gt; &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a9b46077c8db3d50975e124131e52c32f"></a><!-- doxytag: member="IECore::Object::save" ref="a9b46077c8db3d50975e124131e52c32f" args="(SaveContext *context) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void IECore::Object::save </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classIECore_1_1Object_1_1SaveContext.html">SaveContext</a> *&nbsp;</td>
          <td class="paramname"> <em>context</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [protected, pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Must be implemented in all derived classes. Implementations should first call the parent class <a class="el" href="classIECore_1_1Object.html#a3263c27cd23544d3ee7c341e3e9f5265">save()</a> method, then call context-&gt;container() before filling the returned container with their member data. Classes with no member data may omit the call to container(), resulting in smaller file sizes. </p>

<p>Implemented in <a class="el" href="classIECore_1_1TypedData.html#a416d51eaeae85bb3e85cdc130cb053e4">IECore::TypedData&lt; T &gt;</a>, <a class="el" href="classIECore_1_1TypedData.html#a416d51eaeae85bb3e85cdc130cb053e4">IECore::TypedData&lt; CompoundDataMap &gt;</a>, <a class="el" href="classIECore_1_1TypedData.html#a416d51eaeae85bb3e85cdc130cb053e4">IECore::TypedData&lt; int &gt;</a>, <a class="el" href="classIECore_1_1TypedData.html#a416d51eaeae85bb3e85cdc130cb053e4">IECore::TypedData&lt; std::vector&lt; T &gt; &gt;</a>, <a class="el" href="classIECore_1_1TypedData.html#a416d51eaeae85bb3e85cdc130cb053e4">IECore::TypedData&lt; int &gt; &gt;</a>, and <a class="el" href="classIECore_1_1TypedData.html#a416d51eaeae85bb3e85cdc130cb053e4">IECore::TypedData&lt; std::vector&lt; Imath::Vec3&lt; PointBaseType &gt; &gt; &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a3263c27cd23544d3ee7c341e3e9f5265"></a><!-- doxytag: member="IECore::Object::save" ref="a3263c27cd23544d3ee7c341e3e9f5265" args="(IndexedIOInterfacePtr ioInterface, const IndexedIO::EntryID &amp;name) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IECore::Object::save </td>
          <td>(</td>
          <td class="paramtype">IndexedIOInterfacePtr&nbsp;</td>
          <td class="paramname"> <em>ioInterface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IndexedIO::EntryID &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Saves the object in the current directory of ioInterface, in a subdirectory with the specified name. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/IECore/<a class="el" href="Object_8h_source.html">Object.h</a></li>
</ul>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&nbsp;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&nbsp;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&nbsp;</span>Friends</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr size="1"/><address style="text-align: right;"><small>Generated on 5 Jan 2012 for Cortex by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
